###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         21/Dec/2020  23:08:50
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\app.c
#    Command line                 =
#        -f C:\Users\fabi8\AppData\Local\Temp\EW57B1.tmp
#        (D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\app.c
#        -lCN
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List
#        -o
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "D:\Develop\IAR Systems\arm\inc\c\DLib_Config_Normal.h" -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\ports\arm-cortex-m3\generic\iar\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\source\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-lib\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\ARM-Cortex-M3\IAR\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\cpu\st\stm32\inc\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\BSP\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II\\
#        -Ohz --use_c++_inline)
#    Locale                       =  C
#    List file                    =
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List\app.lst
#    Object file                  =
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj\app.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#      __size_limit               =  32768|ARM.EW.LINKER
#
###############################################################################

D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\app.c
      1          /*
      2           *********************************************************************************************************
      3           *                                              TERM PROJECT
      4           *                          (C) Copyright 2020; Lee Seung Yun; Shim Jae Yeong
      5           *               Some codes are referenced below.
      6           * 
      7           *                                              EXAMPLE CODE
      8           *
      9           *                          (c) Copyright 2003-2006; Micrium, Inc.; Weston, FL
     10           *
     11           *               All rights reserved.  Protected by international copyright laws.
     12           *               Knowledge of the source code may NOT be used to develop a similar product.
     13           *               Please help us continue to provide the Embedded community with the finest
     14           *               software available.  Your honesty is greatly appreciated.
     15           *********************************************************************************************************
     16           */
     17          
     18          /*
     19           *********************************************************************************************************
     20           *
     21           *                             High Temperature Entrance Checking Technique
     22           *
     23           *                                     ST Microelectronics STM32
     24           *                                              with the
     25           *                                   STM3210B-EVAL Evaluation Board
     26           *
     27           * Filename      : app.c
     28           * Version       : V1.0
     29           * Programmer(s) : Lee Seung Yun, Shim Jae Yeong
     30           *********************************************************************************************************
     31           */
     32          
     33          /*
     34           *********************************************************************************************************
     35           *                                             INCLUDE FILES
     36           *********************************************************************************************************
     37           */
     38          
     39          #include <includes.h>
     40          #include <stm32f10x_gpio.h>
     41          #include <stm32f10x_rcc.h>
     42          #include <stm32f10x_i2c.h>
     43          #include <stm32f10x_adc.h>
     44          #include <stm32f10x_spi.h>
     45          #include <stm32f10x_tim.h>
     46          
     47          /*
     48           *********************************************************************************************************
     49           *                                            LOCAL DEFINES
     50           *********************************************************************************************************
     51           */
     52          
     53          /*
     54           *********************************************************************************************************
     55           *                                       LOCAL GLOBAL VARIABLES
     56           *********************************************************************************************************
     57           */
     58          
     59          // Task Stack (size: 128)

   \                                 In section .bss, align 4
     60          static OS_STK detectTaskStack[TASK_STK_SIZE];
     61          static OS_STK temperatureTaskStack[TASK_STK_SIZE];
     62          static OS_STK passTaskStack[TASK_STK_SIZE];
     63          static OS_STK denyTaskStack[TASK_STK_SIZE];
     64          static OS_STK checkTaskStack[TASK_STK_SIZE];
     65          static OS_STK displayTaskStack[TASK_STK_SIZE];
     66          
     67          // Message Que
     68          static OS_EVENT *temperQue;
     69          static void *msg[10];
     70          
     71          // Event Flags
     72          static OS_FLAG_GRP *flagGroup;
   \                     flagGroup:
   \        0x0                      DS8 4
   \        0x4                      DS8 4
   \        0x8                      DS8 4
   \        0xC                      DS8 4
   \       0x10                      DS8 256
   \      0x110                      DS8 256
   \      0x210                      DS8 256
   \      0x310                      DS8 256
   \      0x410                      DS8 256
     73          const static OS_FLAGS FLAG_INIT = 0;
     74          const static OS_FLAGS FLAG_DETECT = 1;
     75          const static OS_FLAGS FLAG_DETECT_NOT = 2;
     76          const static OS_FLAGS FLAG_TEMPER_NORMAL = 4;
     77          const static OS_FLAGS FLAG_TEMPER_HIGH = 8;
     78          const static OS_FLAGS FLAG_TEMPER_LOW = 16;
     79          
     80          // time
     81          static OS_EVENT *sem;
     82          static int count = 0;
     83          static int check = 0;
     84          const static int DELAY_TIME = 150;
     85          
     86          static int ADC_value = 0;
     87          /*
     88          static GPIO_TypeDef *orangeTypes[8] = {GPIOC, GPIOA, GPIOA, GPIOA, GPIOB, GPIOC, GPIOA, GPIOA};
     89          const static int orangePins[8] = {GPIO_Pin_7, GPIO_Pin_8, GPIO_Pin_11, GPIO_Pin_14, GPIO_Pin_1, GPIO_Pin_4, GPIO_Pin_5, GPIO_Pin_2};
     90          
     91          static GPIO_TypeDef *greenTypes[8] = {GPIOC, GPIOC, GPIOA, GPIOA, GPIOB, GPIOC, GPIOA, GPIOA};
     92          const static int greenPins[8] = {GPIO_Pin_6, GPIO_Pin_9, GPIO_Pin_10, GPIO_Pin_13, GPIO_Pin_2, GPIO_Pin_5, GPIO_Pin_6, GPIO_Pin_3};
     93          
     94          static GPIO_TypeDef *lineTypes[8] = {GPIOC, GPIOA, GPIOA, GPIOA, GPIOB, GPIOA, GPIOA, GPIOA};
     95          const static int linePins[8] = {GPIO_Pin_8, GPIO_Pin_9, GPIO_Pin_12, GPIO_Pin_15, GPIO_Pin_0, GPIO_Pin_7, GPIO_Pin_4, GPIO_Pin_1};
     96          
     97          const static char shapeX[8][8] = {
     98          	{1, 0, 0, 0, 0, 0, 0, 1},
     99          	{0, 1, 0, 0, 0, 0, 1, 0},
    100          	{0, 0, 1, 0, 0, 1, 0, 0},
    101          	{0, 0, 0, 1, 1, 0, 0, 0},
    102          	{0, 0, 0, 1, 1, 0, 0, 0},
    103          	{0, 0, 1, 0, 0, 1, 0, 0},
    104          	{0, 1, 0, 0, 0, 0, 1, 0},
    105          	{1, 0, 0, 0, 0, 0, 0, 1}};
    106          const static char shapeO[8][8] = {
    107          	{0, 0, 0, 1, 1, 0, 0, 0},
    108          	{0, 1, 1, 0, 0, 1, 1, 0},
    109          	{0, 1, 0, 0, 0, 0, 1, 0},
    110          	{1, 0, 0, 0, 0, 0, 0, 1},
    111          	{1, 0, 0, 0, 0, 0, 0, 1},
    112          	{0, 1, 0, 0, 0, 0, 1, 0},
    113          	{0, 1, 1, 0, 0, 1, 1, 0},
    114          	{1, 0, 0, 1, 1, 0, 0, 1}};
    115          */
    116          #if ((APP_OS_PROBE_EN == DEF_ENABLED) &&  \
    117          	 (APP_PROBE_COM_EN == DEF_ENABLED) && \
    118          	 (PROBE_COM_STAT_EN == DEF_ENABLED))

   \                                 In section .bss, align 4
   \        0x0                      DS8 4
    119          static CPU_FP32 App_ProbeComRxPktSpd;

   \                                 In section .bss, align 4
   \        0x0                      DS8 4
    120          static CPU_FP32 App_ProbeComTxPktSpd;

   \                                 In section .bss, align 4
   \        0x0                      DS8 4
    121          static CPU_FP32 App_ProbeComTxSymSpd;

   \                                 In section .bss, align 4
   \        0x0                      DS8 4
    122          static CPU_FP32 App_ProbeComTxSymByteSpd;
    123          

   \                                 In section .bss, align 4
    124          static CPU_INT32U App_ProbeComRxPktLast;
   \                     App_ProbeComRxPktLast:
   \        0x0                      DS8 4
   \        0x4                      DS8 4
   \        0x8                      DS8 4
   \        0xC                      DS8 4
   \       0x10                      DS8 4
   \       0x14                      DS8 4
    125          static CPU_INT32U App_ProbeComTxPktLast;
    126          static CPU_INT32U App_ProbeComTxSymLast;
    127          static CPU_INT32U App_ProbeComTxSymByteLast;
    128          
    129          static CPU_INT32U App_ProbeComCtrLast;
    130          #endif
    131          
    132          #if (APP_OS_PROBE_EN == DEF_ENABLED)
    133          static CPU_INT32U App_ProbeCounts;

   \                                 In section .bss, align 1
   \        0x0                      DS8 1
    134          static CPU_BOOLEAN App_ProbeB1;
    135          
    136          #endif
    137          
    138          /*
    139           *********************************************************************************************************
    140           *                                      LOCAL FUNCTION PROTOTYPES
    141           *********************************************************************************************************
    142           */
    143          
    144          // Task function
    145          static void detectTask(void *p);
    146          static void temperTask(void *p);
    147          static void passTask(void *p);
    148          static void denyTask(void *p);
    149          static void checkTask(void *p);
    150          static void displayTask(void *p);
    151          
    152          static void App_DispScr_SignOn(void);
    153          static void DispScr_TaskNames(void);
    154          
    155          static int readTemperature(void);
    156          static void stopAll();
    157          static void initAll();
    158          
    159          #if ((APP_PROBE_COM_EN == DEF_ENABLED) || \
    160          	 (APP_OS_PROBE_EN == DEF_ENABLED))
    161          static void App_InitProbe(void);
    162          #endif
    163          
    164          #if (APP_OS_PROBE_EN == DEF_ENABLED)
    165          static void App_ProbeCallback(void);
    166          #endif
    167          
    168          /*
    169           *********************************************************************************************************
    170           *                                                main()
    171           *
    172           * Description : This is the standard entry point for C code.  It is assumed that your code will call
    173           *               main() once you have performed all necessary initialization.
    174           *
    175           * Argument(s) : none.
    176           *
    177           * Return(s)   : none.
    178           *********************************************************************************************************
    179           */
    180          

   \                                 In section .text, align 2, keep-with-next
    181          int main(void)
    182          {
   \                     main: (+1)
   \        0x0   0xB570             PUSH     {R4-R6,LR}
   \        0x2   0xB090             SUB      SP,SP,#+64
    183          	CPU_INT08U os_err;
    184          
    185          	/* Disable all ints until we are ready to accept them.  */
    186          	BSP_IntDisAll();
   \        0x4   0x....'....        BL       BSP_IntDisAll
    187          
    188          	/* Initialize "uC/OS-II, The Real-Time Kernel".         */
    189          	OSInit();
   \        0x8   0x....'....        BL       OSInit
    190          
    191          	initAll();
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0xF44F 0x1000      MOV      R0,#+2097152
   \       0x12   0x....'....        BL       RCC_APB1PeriphClockCmd
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0xF44F 0x4080      MOV      R0,#+16384
   \       0x1C   0x....'....        BL       RCC_APB1PeriphClockCmd
   \       0x20   0x2101             MOVS     R1,#+1
   \       0x22   0x2001             MOVS     R0,#+1
   \       0x24   0x....'....        BL       RCC_APB2PeriphClockCmd
   \       0x28   0x2101             MOVS     R1,#+1
   \       0x2A   0xF44F 0x7000      MOV      R0,#+512
   \       0x2E   0x....'....        BL       RCC_APB2PeriphClockCmd
   \       0x32   0x2101             MOVS     R1,#+1
   \       0x34   0x2004             MOVS     R0,#+4
   \       0x36   0x....'....        BL       RCC_APB2PeriphClockCmd
   \       0x3A   0x2101             MOVS     R1,#+1
   \       0x3C   0x2008             MOVS     R0,#+8
   \       0x3E   0x....'....        BL       RCC_APB2PeriphClockCmd
   \       0x42   0x2101             MOVS     R1,#+1
   \       0x44   0x2010             MOVS     R0,#+16
   \       0x46   0x....'....        BL       RCC_APB2PeriphClockCmd
   \       0x4A   0x2001             MOVS     R0,#+1
   \       0x4C   0x2100             MOVS     R1,#+0
   \       0x4E   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x52   0x....'....        LDR.W    R4,??DataTable12  ;; 0x40010c00
   \       0x56   0x....'....        LDR.W    R5,??DataTable12_1  ;; 0x40011000
   \       0x5A   0x....'....        LDR.W    R6,??DataTable12_2  ;; 0x40012400
   \       0x5E   0x4620             MOV      R0,R4
   \       0x60   0x....'....        BL       GPIO_Init
   \       0x64   0x2002             MOVS     R0,#+2
   \       0x66   0x2100             MOVS     R1,#+0
   \       0x68   0x....'....        BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x6C   0x20C0             MOVS     R0,#+192
   \       0x6E   0x211C             MOVS     R1,#+28
   \       0x70   0x....'....        BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x74   0xF44F 0x7080      MOV      R0,#+256
   \       0x78   0x2110             MOVS     R1,#+16
   \       0x7A   0x....'....        BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x7E   0xF44F 0x5080      MOV      R0,#+4096
   \       0x82   0x2103             MOVS     R1,#+3
   \       0x84   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \       0x88   0xF88D 0x1002      STRB     R1,[SP, #+2]
   \       0x8C   0x2210             MOVS     R2,#+16
   \       0x8E   0xF88D 0x2003      STRB     R2,[SP, #+3]
   \       0x92   0x4669             MOV      R1,SP
   \       0x94   0x4620             MOV      R0,R4
   \       0x96   0x....'....        BL       GPIO_Init
   \       0x9A   0xF44F 0x4060      MOV      R0,#+57344
   \       0x9E   0x2118             MOVS     R1,#+24
   \       0xA0   0x....'....        BL       ?Subroutine0
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0xA4   0xF44F 0x6040      MOV      R0,#+3072
   \       0xA8   0x2110             MOVS     R1,#+16
   \       0xAA   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0xAE   0x4628             MOV      R0,R5
   \       0xB0   0x....'....        BL       GPIO_Init
   \       0xB4   0x2201             MOVS     R2,#+1
   \       0xB6   0xF88D 0x2030      STRB     R2,[SP, #+48]
   \       0xBA   0xF88D 0x2031      STRB     R2,[SP, #+49]
   \       0xBE   0x2100             MOVS     R1,#+0
   \       0xC0   0xF44F 0x2260      MOV      R2,#+917504
   \       0xC4   0x920D             STR      R2,[SP, #+52]
   \       0xC6   0x910B             STR      R1,[SP, #+44]
   \       0xC8   0x910E             STR      R1,[SP, #+56]
   \       0xCA   0x2202             MOVS     R2,#+2
   \       0xCC   0xF88D 0x203C      STRB     R2,[SP, #+60]
   \       0xD0   0xA90B             ADD      R1,SP,#+44
   \       0xD2   0x4630             MOV      R0,R6
   \       0xD4   0x....'....        BL       ADC_Init
   \       0xD8   0x2304             MOVS     R3,#+4
   \       0xDA   0x2201             MOVS     R2,#+1
   \       0xDC   0x2108             MOVS     R1,#+8
   \       0xDE   0x4630             MOV      R0,R6
   \       0xE0   0x....'....        BL       ADC_RegularChannelConfig
   \       0xE4   0x2101             MOVS     R1,#+1
   \       0xE6   0x4630             MOV      R0,R6
   \       0xE8   0x....'....        BL       ADC_Cmd
   \       0xEC   0x4630             MOV      R0,R6
   \       0xEE   0x....'....        BL       ADC_ResetCalibration
   \                     ??main_0: (+1)
   \       0xF2   0x4630             MOV      R0,R6
   \       0xF4   0x....'....        BL       ADC_GetResetCalibrationStatus
   \       0xF8   0x2800             CMP      R0,#+0
   \       0xFA   0xD1FA             BNE.N    ??main_0
   \       0xFC   0x4630             MOV      R0,R6
   \       0xFE   0x....'....        BL       ADC_StartCalibration
   \                     ??main_1: (+1)
   \      0x102   0x4630             MOV      R0,R6
   \      0x104   0x....'....        BL       ADC_GetCalibrationStatus
   \      0x108   0x2800             CMP      R0,#+0
   \      0x10A   0xD1FA             BNE.N    ??main_1
   \      0x10C   0x2101             MOVS     R1,#+1
   \      0x10E   0x4630             MOV      R0,R6
   \      0x110   0x....'....        BL       ADC_SoftwareStartConvCmd
   \      0x114   0xF64B 0x72FF      MOVW     R2,#+49151
   \      0x118   0xF8AD 0x2006      STRH     R2,[SP, #+6]
   \      0x11C   0x2100             MOVS     R1,#+0
   \      0x11E   0xF8AD 0x1004      STRH     R1,[SP, #+4]
   \      0x122   0xF8AD 0x1008      STRH     R1,[SP, #+8]
   \      0x126   0xF44F 0x6280      MOV      R2,#+1024
   \      0x12A   0xF8AD 0x200A      STRH     R2,[SP, #+10]
   \      0x12E   0xF44F 0x4180      MOV      R1,#+16384
   \      0x132   0xF8AD 0x100C      STRH     R1,[SP, #+12]
   \      0x136   0xA901             ADD      R1,SP,#+4
   \      0x138   0x....'....        LDR.W    R2,??DataTable12_3  ;; 0x186a0
   \      0x13C   0x....'....        LDR.W    R6,??DataTable12_4  ;; 0x40005400
   \      0x140   0x9204             STR      R2,[SP, #+16]
   \      0x142   0x4630             MOV      R0,R6
   \      0x144   0x....'....        BL       I2C_Init
   \      0x148   0x2101             MOVS     R1,#+1
   \      0x14A   0x4630             MOV      R0,R6
   \      0x14C   0x....'....        BL       I2C_Cmd
   \      0x150   0xF44F 0x7282      MOV      R2,#+260
   \      0x154   0xF8AD 0x201A      STRH     R2,[SP, #+26]
   \      0x158   0xF44F 0x4140      MOV      R1,#+49152
   \      0x15C   0xF8AD 0x1018      STRH     R1,[SP, #+24]
   \      0x160   0x2200             MOVS     R2,#+0
   \      0x162   0xF8AD 0x201E      STRH     R2,[SP, #+30]
   \      0x166   0xF8AD 0x2020      STRH     R2,[SP, #+32]
   \      0x16A   0xF44F 0x6100      MOV      R1,#+2048
   \      0x16E   0xF8AD 0x101C      STRH     R1,[SP, #+28]
   \      0x172   0xF44F 0x7200      MOV      R2,#+512
   \      0x176   0xF8AD 0x2022      STRH     R2,[SP, #+34]
   \      0x17A   0x2110             MOVS     R1,#+16
   \      0x17C   0xF8AD 0x1024      STRH     R1,[SP, #+36]
   \      0x180   0x2200             MOVS     R2,#+0
   \      0x182   0xF8AD 0x2026      STRH     R2,[SP, #+38]
   \      0x186   0xA906             ADD      R1,SP,#+24
   \      0x188   0x....'....        LDR.W    R6,??DataTable12_5  ;; 0x40003800
   \      0x18C   0x4630             MOV      R0,R6
   \      0x18E   0x....'....        BL       SPI_Init
   \      0x192   0x2101             MOVS     R1,#+1
   \      0x194   0x4630             MOV      R0,R6
   \      0x196   0x....'....        BL       SPI_Cmd
    192          
    193          	// Create Message Que, msg : 저장공간, 크기 : 10
    194          	//temperQue = (OS_EVENT *)OSQCreate(msg, 10);
    195          
    196          	// Create semaphore
    197          	sem = OSSemCreate(0);
   \      0x19A   0x2000             MOVS     R0,#+0
   \      0x19C   0x....'....        LDR.W    R6,??DataTable12_6
   \      0x1A0   0x....'....        BL       OSSemCreate
   \      0x1A4   0x6070             STR      R0,[R6, #+4]
    198          
    199          	os_err = OSTaskCreateExt((void (*)(void *))detectTask,						   // Task가 수행할 함수, 사람의 존재 유/무를 알려주는 Task
    200          							 (void *)0,											   // Task로 넘겨줄 인자
    201          							 (OS_STK *)&detectTaskStack[TASK_STK_SIZE - 1],		   // Task가 할당될 Stack의 Top을 가리키는 주소
    202          							 (INT8U)TASK_DETECT_PRIO,							   // Task의 우선 순위 (MPT)
    203          							 (INT16U)TASK_DETECT_PRIO,							   // Task를 지칭하는 유일한 식별자, Task 갯수의 극복을 위해서 사용할 예정, 현재는 우선 순위와 같게끔 설정
    204          							 (OS_STK *)&detectTaskStack,						   // Task가 할당될 Stack의 마지막을 가리키는 주소, Stack 검사용으로 사용
    205          							 (INT32U)TASK_STK_SIZE,								   // Task Stack의 크기를 의미
    206          							 (void *)0,											   // Task Control Block 활용시 사용
    207          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK)); // Task 생성 옵션
   \      0x1A6   0x....'....        BL       ??Subroutine5_0
   \                     ??CrossCallReturnLabel_23: (+1)
   \      0x1AA   0xF106 0x0310      ADD      R3,R6,#+16
   \      0x1AE   0x2002             MOVS     R0,#+2
   \      0x1B0   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_4: (+1)
   \      0x1B4   0x2302             MOVS     R3,#+2
   \      0x1B6   0xF506 0x7286      ADD      R2,R6,#+268
   \      0x1BA   0x....'....        ADR.W    R0,detectTask
   \      0x1BE   0x....'....        BL       OSTaskCreateExt
   \      0x1C2   0xF88D 0x0014      STRB     R0,[SP, #+20]
    208          
    209          	os_err = OSTaskCreateExt((void (*)(void *))temperTask, // 사람의 온도를 측정하여 통과할지 말지를 결정하는 Task
    210          							 (void *)0,
    211          							 (OS_STK *)&temperatureTaskStack[TASK_STK_SIZE - 1],
    212          							 (INT8U)TASK_TEMPER_PRIO,
    213          							 (INT16U)TASK_TEMPER_PRIO,
    214          							 (OS_STK *)&temperatureTaskStack,
    215          							 (INT32U)TASK_STK_SIZE,
    216          							 (void *)0,
    217          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
   \      0x1C6   0x2240             MOVS     R2,#+64
   \      0x1C8   0x2003             MOVS     R0,#+3
   \      0x1CA   0xF506 0x7388      ADD      R3,R6,#+272
   \      0x1CE   0x9004             STR      R0,[SP, #+16]
   \      0x1D0   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_5: (+1)
   \      0x1D4   0x2303             MOVS     R3,#+3
   \      0x1D6   0xF506 0x7203      ADD      R2,R6,#+524
   \      0x1DA   0x....'....        ADR.W    R0,temperTask
   \      0x1DE   0x....'....        BL       OSTaskCreateExt
   \      0x1E2   0x....'....        BL       ?Subroutine5
    218          
    219          	os_err = OSTaskCreateExt((void (*)(void *))passTask, // 정상체온인 사람은 통과를 허가하는 Task
    220          							 (void *)0,
    221          							 (OS_STK *)&passTaskStack[TASK_STK_SIZE - 1],
    222          							 (INT8U)TASK_PASS_PRIO,
    223          							 (INT16U)TASK_PASS_PRIO,
    224          							 (OS_STK *)&passTaskStack,
    225          							 (INT32U)TASK_STK_SIZE,
    226          							 (void *)0,
    227          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
   \                     ??CrossCallReturnLabel_20: (+1)
   \      0x1E6   0xF506 0x7304      ADD      R3,R6,#+528
   \      0x1EA   0x2005             MOVS     R0,#+5
   \      0x1EC   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_6: (+1)
   \      0x1F0   0x2305             MOVS     R3,#+5
   \      0x1F2   0xF506 0x7243      ADD      R2,R6,#+780
   \      0x1F6   0x....'....        ADR.W    R0,passTask
   \      0x1FA   0x....'....        BL       OSTaskCreateExt
   \      0x1FE   0x....'....        BL       ?Subroutine5
    228          
    229          	os_err = OSTaskCreateExt((void (*)(void *))denyTask, // 비정상체온인 사람은 통과를 불허하는 Task
    230          							 (void *)0,
    231          							 (OS_STK *)&denyTaskStack[TASK_STK_SIZE - 1],
    232          							 (INT8U)TASK_DENY_PRIO,
    233          							 (INT16U)TASK_DENY_PRIO,
    234          							 (OS_STK *)&denyTaskStack,
    235          							 (INT32U)TASK_STK_SIZE,
    236          							 (void *)0,
    237          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
   \                     ??CrossCallReturnLabel_21: (+1)
   \      0x202   0xF506 0x7344      ADD      R3,R6,#+784
   \      0x206   0x2006             MOVS     R0,#+6
   \      0x208   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_7: (+1)
   \      0x20C   0x2306             MOVS     R3,#+6
   \      0x20E   0xF206 0x420C      ADDW     R2,R6,#+1036
   \      0x212   0x....'....        ADR.W    R0,denyTask
   \      0x216   0x....'....        BL       OSTaskCreateExt
   \      0x21A   0x....'....        BL       ?Subroutine5
    238          
    239          	os_err = OSTaskCreateExt((void (*)(void *))checkTask, // 알림 장치 작동 중지하는 Task
    240          							 (void *)0,
    241          							 (OS_STK *)&checkTaskStack[TASK_STK_SIZE - 1],
    242          							 (INT8U)TASK_CHECK_PRIO,
    243          							 (INT16U)TASK_CHECK_PRIO,
    244          							 (OS_STK *)&checkTaskStack,
    245          							 (INT32U)TASK_STK_SIZE,
    246          							 (void *)0,
    247          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
   \                     ??CrossCallReturnLabel_22: (+1)
   \      0x21E   0xF506 0x6382      ADD      R3,R6,#+1040
   \      0x222   0x2001             MOVS     R0,#+1
   \      0x224   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_8: (+1)
   \      0x228   0x2301             MOVS     R3,#+1
   \      0x22A   0xF206 0x520C      ADDW     R2,R6,#+1292
   \      0x22E   0x....'....        ADR.W    R0,checkTask
   \      0x232   0x....'....        BL       OSTaskCreateExt
   \      0x236   0xF88D 0x0014      STRB     R0,[SP, #+20]
    248          
    249          							 for(int i = 0; i < 300000; i++){
    250          			
    251          		}
    252          		GPIO_SetBits(GPIOB, GPIO_Pin_8);
   \      0x23A   0xF44F 0x7180      MOV      R1,#+256
   \      0x23E   0x4620             MOV      R0,R4
   \      0x240   0x....'....        BL       GPIO_SetBits
    253          			GPIO_SetBits(GPIOC, GPIO_Pin_10);
   \      0x244   0xF44F 0x6180      MOV      R1,#+1024
   \      0x248   0x4628             MOV      R0,R5
   \      0x24A   0x....'....        BL       GPIO_SetBits
    254          			for(int i = 0; i < 300000; i++){
    255          			
    256          		}
    257          		GPIO_ResetBits(GPIOB, GPIO_Pin_8);
   \      0x24E   0xF44F 0x7180      MOV      R1,#+256
   \      0x252   0x4620             MOV      R0,R4
   \      0x254   0x....'....        BL       GPIO_ResetBits
    258          			GPIO_ResetBits(GPIOC, GPIO_Pin_10);
   \      0x258   0x....'....        BL       ?Subroutine7
    259          			for(int i = 0; i < 300000; i++){
    260          			
    261          		}
    262          
    263          /*	os_err = OSTaskCreateExt((void (*)(void *))displayTask, // dot-matrix 표시하는 Task
    264          							 (void *)0,
    265          							 (OS_STK *)&displayTaskStack[TASK_STK_SIZE - 1],
    266          							 (INT8U)TASK_DISPLAY_PRIO,
    267          							 (INT16U)TASK_DISPLAY_PRIO,
    268          							 (OS_STK *)&displayTaskStack,
    269          							 (INT32U)TASK_STK_SIZE,
    270          							 (void *)0,
    271          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
    272          */
    273          #if (OS_TASK_NAME_SIZE >= 11)
    274          	OSTaskNameSet(TASK_DETECT_PRIO, (CPU_INT08U *)"Detect Task", &os_err);
   \                     ??CrossCallReturnLabel_30: (+1)
   \      0x25C   0xAA05             ADD      R2,SP,#+20
   \      0x25E   0x....'....        ADR.W    R1,?_0
   \      0x262   0x2002             MOVS     R0,#+2
   \      0x264   0x....'....        BL       OSTaskNameSet
    275          	OSTaskNameSet(TASK_TEMPER_PRIO, (CPU_INT08U *)"Temperature Task", &os_err);
   \      0x268   0xAA05             ADD      R2,SP,#+20
   \      0x26A   0x....'....        ADR.W    R1,?_1
   \      0x26E   0x2003             MOVS     R0,#+3
   \      0x270   0x....'....        BL       OSTaskNameSet
    276          	OSTaskNameSet(TASK_PASS_PRIO, (CPU_INT08U *)"Pass Task", &os_err);
   \      0x274   0xAA05             ADD      R2,SP,#+20
   \      0x276   0x....'....        ADR.W    R1,?_2
   \      0x27A   0x2005             MOVS     R0,#+5
   \      0x27C   0x....'....        BL       OSTaskNameSet
    277          	OSTaskNameSet(TASK_DENY_PRIO, (CPU_INT08U *)"Deny Task", &os_err);
   \      0x280   0xAA05             ADD      R2,SP,#+20
   \      0x282   0x....'....        ADR.W    R1,?_3
   \      0x286   0x2006             MOVS     R0,#+6
   \      0x288   0x....'....        BL       OSTaskNameSet
    278          	OSTaskNameSet(TASK_CHECK_PRIO, (CPU_INT08U *)"Check Task", &os_err);
   \      0x28C   0xAA05             ADD      R2,SP,#+20
   \      0x28E   0x....'....        ADR.W    R1,?_4
   \      0x292   0x2001             MOVS     R0,#+1
   \      0x294   0x....'....        BL       OSTaskNameSet
    279          	//OSTaskNameSet(TASK_DISPLAY_PRIO, (CPU_INT08U *)"Display Task", &os_err);
    280          #endif
    281          
    282          	OSStart(); /* Start multitasking (i.e. give control to uC/OS-II).  */
   \      0x298   0x....'....        BL       OSStart
    283          
    284          	return (0);
   \      0x29C   0x2000             MOVS     R0,#+0
   \      0x29E   0xB010             ADD      SP,SP,#+64
   \      0x2A0   0xBD70             POP      {R4-R6,PC}       ;; return
    285          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0xF88D 0x0014      STRB     R0,[SP, #+20]
   \                     ??Subroutine5_0: (+1)
   \        0x4   0x2240             MOVS     R2,#+64
   \        0x6   0x2003             MOVS     R0,#+3
   \        0x8   0x9004             STR      R0,[SP, #+16]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x9202             STR      R2,[SP, #+8]
   \        0x4   0x9301             STR      R3,[SP, #+4]
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0x9103             STR      R1,[SP, #+12]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0xF44F 0x6180      MOV      R1,#+1024
   \        0x4   0x4628             MOV      R0,R5
   \        0x6   0x....'....        B.W      GPIO_ResetBits
    286          
    287          /*
    288           *********************************************************************************************************
    289           *                                          detectTask()
    290           *
    291           * Description : Human detecting task. Monitor the existence of people,
    292           *
    293           * Argument(s) : p
    294           *
    295           * Return(s)   : none.
    296           *
    297           * Caller(s)   : This is a task.
    298           *
    299           * Note(s)     : none.
    300           *********************************************************************************************************
    301           */
    302          
    303          // Task가 수행할 함수, 사람의 존재 유/무를 알려주는 Task

   \                                 In section .text, align 4, keep-with-next
    304          static void detectTask(void *p)
    305          {
   \                     detectTask: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    306          	CPU_INT08U err;
    307          
    308          	while (DEF_TRUE)
    309          	{
    310          		int exist = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1);
    311          
    312          		
    313          
    314          		if (exist != 0) // when human detected
   \                     ??detectTask_0: (+1)
   \        0x2   0x2102             MOVS     R1,#+2
   \        0x4   0x....             LDR.N    R0,??DataTable12  ;; 0x40010c00
   \        0x6   0x....'....        BL       GPIO_ReadInputDataBit
   \        0xA   0x2800             CMP      R0,#+0
    315          		{
    316          			OSFlagPost(flagGroup, FLAG_DETECT, OS_FLAG_SET, &err);
    317          		}
    318          		else
    319          		{
    320          			OSFlagPost(flagGroup, FLAG_DETECT_NOT, OS_FLAG_SET, &err);
   \        0xC   0x....             LDR.N    R0,??DataTable12_6
   \        0xE   0x6800             LDR      R0,[R0, #+0]
   \       0x10   0x466B             MOV      R3,SP
   \       0x12   0xBF07             ITTEE    EQ
   \       0x14   0x2201             MOVEQ    R2,#+1
   \       0x16   0x2102             MOVEQ    R1,#+2
   \       0x18   0x2201             MOVNE    R2,#+1
   \       0x1A   0x2101             MOVNE    R1,#+1
   \       0x1C   0x....'....        BL       OSFlagPost
    321          		}
    322          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
   \       0x20   0x....'....        BL       ?Subroutine2
    323          	}
   \                     ??CrossCallReturnLabel_13: (+1)
   \       0x24   0xE7ED             B.N      ??detectTask_0
    324          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0x2396             MOVS     R3,#+150
   \        0x2   0x2200             MOVS     R2,#+0
   \                     ??Subroutine2_0: (+1)
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x2000             MOVS     R0,#+0
   \        0x8   0x....'....        B.W      OSTimeDlyHMSM
    325          
    326          /*
    327           *********************************************************************************************************
    328           *                                            temperTask()
    329           *
    330           * Description : Measure a person's temperature
    331           *
    332           * Argument(s) : p
    333           *
    334           * Return(s)   : none.
    335           *
    336           * Caller(s)   : This is a task.
    337           *
    338           * Note(s)     : none.
    339           *********************************************************************************************************
    340           */
    341          
    342          // 사람의 온도를 측정하여 통과할지 말지를 결정하는 Task

   \                                 In section .text, align 4, keep-with-next
    343          static void temperTask(void *p)
    344          {
   \                     temperTask: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    345          	INT8U err;
    346          	int temp;
    347          	int high = 39;
    348          	int low = 34;
   \        0x2   0x....             LDR.N    R4,??DataTable12_6
    349          	while (DEF_TRUE)
    350          	{
    351          		temp = 50;		 //ADC_GetConversionValue(ADC1) / 50;
    352          		if (temp > high) // when temperature is HIGH
    353          		{
    354          			OSFlagPost(flagGroup, FLAG_TEMPER_HIGH, OS_FLAG_SET, &err);
   \                     ??temperTask_0: (+1)
   \        0x4   0x6820             LDR      R0,[R4, #+0]
   \        0x6   0x466B             MOV      R3,SP
   \        0x8   0x2201             MOVS     R2,#+1
   \        0xA   0x2108             MOVS     R1,#+8
   \        0xC   0x....'....        BL       OSFlagPost
    355          		}
    356          		else if (temp < low)
    357          		{
    358          			OSFlagPost(flagGroup, FLAG_TEMPER_LOW, OS_FLAG_SET, &err);
    359          		}
    360          		else
    361          		{
    362          			OSFlagPost(flagGroup, FLAG_TEMPER_NORMAL, OS_FLAG_SET, &err);
    363          		}
    364          
    365          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
   \       0x10   0x....'....        BL       ?Subroutine2
    366          	}
   \                     ??CrossCallReturnLabel_12: (+1)
   \       0x14   0xE7F6             B.N      ??temperTask_0
    367          }

   \                                 In section .text, align 2, keep-with-next
    368          void i2c_multi_read(int Device_Addr, int Reg, int *pBuffer, int NumByteToRead)
    369          
    370          {
   \                     i2c_multi_read: (+1)
   \        0x0   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \        0x4   0x4605             MOV      R5,R0
   \        0x6   0x460E             MOV      R6,R1
   \        0x8   0x4617             MOV      R7,R2
   \        0xA   0x461C             MOV      R4,R3
   \        0xC   0x....'....        LDR.W    R8,??DataTable12_4  ;; 0x40005400
    371          
    372          	/* While the bus is busy */
    373          
    374          	while (I2C_GetFlagStatus(((I2C_TypeDef *)I2C1_BASE), I2C_FLAG_BUSY))
   \                     ??i2c_multi_read_0: (+1)
   \       0x10   0xF44F 0x3100      MOV      R1,#+131072
   \       0x14   0x4640             MOV      R0,R8
   \       0x16   0x....'....        BL       I2C_GetFlagStatus
   \       0x1A   0x2800             CMP      R0,#+0
   \       0x1C   0xD1F8             BNE.N    ??i2c_multi_read_0
    375          		;
    376          
    377          	/* Send START condition */
    378          
    379          	I2C_GenerateSTART(((I2C_TypeDef *)I2C1_BASE), ENABLE);
   \       0x1E   0x2101             MOVS     R1,#+1
   \       0x20   0x4640             MOV      R0,R8
   \       0x22   0x....'....        BL       I2C_GenerateSTART
   \       0x26   0x....'....        LDR.W    R9,??DataTable12_7  ;; 0x30001
    380          
    381          	/* Test on EV5 and clear it */
    382          
    383          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_MODE_SELECT))
   \                     ??i2c_multi_read_1: (+1)
   \       0x2A   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_28: (+1)
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD0FB             BEQ.N    ??i2c_multi_read_1
    384          		;
    385          
    386          	/* Send slave address for write */
    387          
    388          	I2C_Send7bitAddress(((I2C_TypeDef *)I2C1_BASE), Device_Addr, I2C_Direction_Transmitter);
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0xB2E9             UXTB     R1,R5
   \       0x36   0x4640             MOV      R0,R8
   \       0x38   0x....'....        BL       I2C_Send7bitAddress
    389          
    390          	/* Test on EV6 and clear it */
    391          
    392          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
   \                     ??i2c_multi_read_2: (+1)
   \       0x3C   0x....             LDR.N    R1,??DataTable12_8  ;; 0x70082
   \       0x3E   0x....'....        BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD0FA             BEQ.N    ??i2c_multi_read_2
    393          		;
    394          
    395          	/* Send the device internal address to read from: Only one byte address */
    396          
    397          	I2C_SendData(((I2C_TypeDef *)I2C1_BASE), Reg);
   \       0x46   0xB2F1             UXTB     R1,R6
   \       0x48   0x4640             MOV      R0,R8
   \       0x4A   0x....'....        BL       I2C_SendData
    398          
    399          	/* Test on EV8 and clear it */
    400          
    401          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_BYTE_TRANSMITTED))
   \                     ??i2c_multi_read_3: (+1)
   \       0x4E   0x....             LDR.N    R1,??DataTable12_9  ;; 0x70084
   \       0x50   0x....'....        BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_25: (+1)
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD0FA             BEQ.N    ??i2c_multi_read_3
    402          		;
    403          
    404          	/* Send STOP condition */
    405          
    406          	I2C_GenerateSTOP(((I2C_TypeDef *)I2C1_BASE), ENABLE);
   \       0x58   0x2101             MOVS     R1,#+1
   \       0x5A   0x4640             MOV      R0,R8
   \       0x5C   0x....'....        BL       I2C_GenerateSTOP
    407          
    408          	/********************************/
    409          
    410          	/* Send STRAT condition a second time */
    411          
    412          	I2C_GenerateSTART(((I2C_TypeDef *)I2C1_BASE), ENABLE);
   \       0x60   0x2101             MOVS     R1,#+1
   \       0x62   0x4640             MOV      R0,R8
   \       0x64   0x....'....        BL       I2C_GenerateSTART
    413          
    414          	/* Test on EV5 and clear it */
    415          
    416          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_MODE_SELECT))
   \                     ??i2c_multi_read_4: (+1)
   \       0x68   0x....'....        BL       ?Subroutine6
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD0FB             BEQ.N    ??i2c_multi_read_4
    417          		;
    418          
    419          	/* Send device address for read */
    420          
    421          	I2C_Send7bitAddress(((I2C_TypeDef *)I2C1_BASE), Device_Addr, I2C_Direction_Receiver);
   \       0x70   0x2201             MOVS     R2,#+1
   \       0x72   0xB2E9             UXTB     R1,R5
   \       0x74   0x4640             MOV      R0,R8
   \       0x76   0x....'....        BL       I2C_Send7bitAddress
    422          
    423          	/* Test on EV6 and clear it */
    424          
    425          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
   \                     ??i2c_multi_read_5: (+1)
   \       0x7A   0x....             LDR.N    R1,??DataTable12_10  ;; 0x30002
   \       0x7C   0x....'....        BL       ??Subroutine6_0
   \                     ??CrossCallReturnLabel_24: (+1)
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD0FA             BEQ.N    ??i2c_multi_read_5
    426          		;
    427          
    428          	/* While there is data to be read */
    429          
    430          	while (NumByteToRead)
   \                     ??i2c_multi_read_6: (+1)
   \       0x84   0xB1AC             CBZ.N    R4,??i2c_multi_read_7
    431          
    432          	{
    433          
    434          		if (NumByteToRead == 1)
   \       0x86   0x2C01             CMP      R4,#+1
   \       0x88   0xD107             BNE.N    ??i2c_multi_read_8
    435          
    436          		{
    437          
    438          			/* Disable Acknowledgement */
    439          
    440          			I2C_AcknowledgeConfig(((I2C_TypeDef *)I2C1_BASE), DISABLE);
   \       0x8A   0x2100             MOVS     R1,#+0
   \       0x8C   0x4640             MOV      R0,R8
   \       0x8E   0x....'....        BL       I2C_AcknowledgeConfig
    441          
    442          			/* Send STOP Condition */
    443          
    444          			I2C_GenerateSTOP(((I2C_TypeDef *)I2C1_BASE), ENABLE);
   \       0x92   0x2101             MOVS     R1,#+1
   \       0x94   0x4640             MOV      R0,R8
   \       0x96   0x....'....        BL       I2C_GenerateSTOP
    445          		}
    446          
    447          		while ((I2C_GetLastEvent(((I2C_TypeDef *)I2C1_BASE)) & 0x0040) != 0x000040)
   \                     ??i2c_multi_read_8: (+1)
   \       0x9A   0x4640             MOV      R0,R8
   \       0x9C   0x....'....        BL       I2C_GetLastEvent
   \       0xA0   0x0640             LSLS     R0,R0,#+25
   \       0xA2   0xD5FA             BPL.N    ??i2c_multi_read_8
    448          			; /* Poll on RxNE */
    449          
    450          		/* Read a byte from the EEPROM */
    451          
    452          		*pBuffer = I2C_ReceiveData(((I2C_TypeDef *)I2C1_BASE));
   \       0xA4   0x4640             MOV      R0,R8
   \       0xA6   0x....'....        BL       I2C_ReceiveData
   \       0xAA   0xF847 0x0B04      STR      R0,[R7], #+4
    453          
    454          		/* Point to the next location where the byte read will be saved */
    455          
    456          		pBuffer++;
    457          
    458          		/* Decrement the read bytes counter */
    459          
    460          		NumByteToRead--;
   \       0xAE   0x1E64             SUBS     R4,R4,#+1
   \       0xB0   0xE7E8             B.N      ??i2c_multi_read_6
    461          	}
    462          
    463          	/* Enable Acknowledgement to be ready for another reception */
    464          
    465          	I2C_AcknowledgeConfig(((I2C_TypeDef *)I2C1_BASE), ENABLE);
   \                     ??i2c_multi_read_7: (+1)
   \       0xB2   0x4640             MOV      R0,R8
   \       0xB4   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \       0xB8   0x2101             MOVS     R1,#+1
   \       0xBA   0x....'....        B.W      I2C_AcknowledgeConfig
    466          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0x4649             MOV      R1,R9
   \                     ??Subroutine6_0: (+1)
   \        0x2   0x4640             MOV      R0,R8
   \        0x4   0x....'....        B.W      I2C_CheckEvent
    467          
    468          static int readTemperature()
    469          {
    470          	int state = 0;
    471          	I2C_GenerateSTART(((I2C_TypeDef *)I2C1_BASE), ENABLE);
    472          	I2C_Send7bitAddress(((I2C_TypeDef *)I2C1_BASE), 0x74, I2C_Direction_Transmitter);
    473          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
    474          		state = I2C_GetLastEvent(((I2C_TypeDef *)I2C1_BASE));
    475          
    476          	I2C_SendData(((I2C_TypeDef *)I2C1_BASE), 0x07);
    477          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_BYTE_TRANSMITTED))
    478          		state = I2C_GetLastEvent(((I2C_TypeDef *)I2C1_BASE));
    479          	//I2C_GenerateSTOP(((I2C_TypeDef *)I2C1_BASE), ENABLE); // check
    480          
    481          	I2C_GenerateSTART(((I2C_TypeDef *)I2C1_BASE), ENABLE);
    482          	//while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_MODE_SELECT))
    483          	//	; // check
    484          	//I2C_SendData(I2C1, 0x75);
    485          	I2C_Send7bitAddress(((I2C_TypeDef *)I2C1_BASE), 0x75, I2C_Direction_Transmitter);
    486          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_MODE_SELECT))
    487          		state = I2C_GetLastEvent(((I2C_TypeDef *)I2C1_BASE));
    488          
    489          	int low = I2C_ReceiveData(((I2C_TypeDef *)I2C1_BASE));
    490          	I2C_AcknowledgeConfig(((I2C_TypeDef *)I2C1_BASE), ENABLE);
    491          
    492          	int high = I2C_ReceiveData(((I2C_TypeDef *)I2C1_BASE));
    493          	I2C_AcknowledgeConfig(((I2C_TypeDef *)I2C1_BASE), ENABLE);
    494          
    495          	int pec = I2C_GetPEC(((I2C_TypeDef *)I2C1_BASE));
    496          	I2C_GenerateSTOP(((I2C_TypeDef *)I2C1_BASE), ENABLE);
    497          
    498          	if (high & 0x80 != 0)
    499          	{
    500          		return -1;
    501          	}
    502          	else
    503          	{
    504          		return (high << 8 + low) * 0.02 - 273.15;
    505          	}
    506          }
    507          
    508          /*
    509           *********************************************************************************************************
    510           *                                            passTask()
    511           *
    512           * Description : Those who are at normal body temperature are allowed to pass.
    513           *
    514           * Argument(s) : p
    515           *
    516           * Return(s)   : none.
    517           *
    518           * Caller(s)   : This is a task.
    519           *
    520           * Note(s)     : none.
    521           *********************************************************************************************************
    522           */
    523          // 정상체온인 사람은 통과를 허가하는 Task

   \                                 In section .text, align 4, keep-with-next
    524          static void passTask(void *p)
    525          {
   \                     passTask: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
   \        0x2   0x....             LDR.N    R4,??DataTable12_6
    526          	int err;
    527          	while (DEF_TRUE)
    528          	{
    529          		OSFlagPend(flagGroup, FLAG_DETECT + FLAG_TEMPER_NORMAL, OS_FLAG_WAIT_SET_ALL + OS_FLAG_CONSUME, 0, (INT8U *)&err);
   \                     ??passTask_0: (+1)
   \        0x4   0xA801             ADD      R0,SP,#+4
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x2282             MOVS     R2,#+130
   \        0xE   0x2105             MOVS     R1,#+5
   \       0x10   0x....'....        BL       OSFlagPend
    530          		//GPIO_SetBits(GPIOC, GPIO_Pin_11);
    531          		
    532          		
    533          
    534          		OSSemPend(sem, 0, (INT8U *)&err);
   \       0x14   0x....'....        BL       ?Subroutine4
    535          		if (count == 0)
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x18   0x....'....        BL       ?Subroutine8
    536          		{
    537          			count = 1;
    538          		}
    539          		OSSemPost(sem);
    540          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0x1C   0x....'....        BL       ?Subroutine2
    541          	}
   \                     ??CrossCallReturnLabel_11: (+1)
   \       0x20   0xE7F0             B.N      ??passTask_0
    542          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x6860             LDR      R0,[R4, #+4]
   \        0x2   0xAA01             ADD      R2,SP,#+4
   \                     ??Subroutine4_0: (+1)
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x....'....        B.W      OSSemPend

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x68A0             LDR      R0,[R4, #+8]
   \        0x2   0xB908             CBNZ.N   R0,??Subroutine8_0
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x60A1             STR      R1,[R4, #+8]
   \                     ??Subroutine8_0: (+1)
   \        0x8   0x6860             LDR      R0,[R4, #+4]
   \        0xA   0x....'....        B.W      OSSemPost
    543          
    544          /*
    545           *********************************************************************************************************
    546           *                                            denyTask()
    547           *
    548           * Description : People with abnormal body temperature are not allowed to pass through.
    549           *
    550           * Argument(s) : p
    551           *
    552           * Return(s)   : none.
    553           *
    554           * Caller(s)   : This is a task.
    555           *
    556           * Note(s)     : none.
    557           *********************************************************************************************************
    558           */
    559          // 비정상체온인 사람은 통과를 불허하는 Task

   \                                 In section .text, align 4, keep-with-next
    560          static void denyTask(void *p)
    561          {
   \                     denyTask: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    562          	int err;
    563          	int temp = 0;
   \        0x2   0x....             LDR.N    R4,??DataTable12_6
    564          	while (DEF_TRUE)
    565          	{
    566          		int flags =
    567          			OSFlagPend(flagGroup,
    568          					   FLAG_TEMPER_HIGH + FLAG_TEMPER_LOW + FLAG_DETECT_NOT,
    569          					   OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
    570          					   0,
    571          					   (INT8U *)&err);
   \                     ??denyTask_0: (+1)
   \        0x4   0xA801             ADD      R0,SP,#+4
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0x2300             MOVS     R3,#+0
   \        0xA   0x6820             LDR      R0,[R4, #+0]
   \        0xC   0x2283             MOVS     R2,#+131
   \        0xE   0x211A             MOVS     R1,#+26
   \       0x10   0x....'....        BL       OSFlagPend
    572          		if ((flags & FLAG_TEMPER_HIGH) != 0 && (flags & FLAG_DETECT_NOT) == 0)
   \       0x14   0xF000 0x010A      AND      R1,R0,#0xA
   \       0x18   0x2908             CMP      R1,#+8
   \       0x1A   0xBF1C             ITT      NE
   \       0x1C   0xF000 0x0012      ANDNE    R0,R0,#0x12
   \       0x20   0x2810             CMPNE    R0,#+16
    573          		{
    574          			GPIO_SetBits(GPIOC, GPIO_Pin_10);
    575          			// piezo
    576          			GPIO_SetBits(GPIOB, GPIO_Pin_8);
    577          		}
    578          		else if ((flags & FLAG_TEMPER_LOW) != 0 && (flags & FLAG_DETECT_NOT) == 0)
   \       0x22   0xD109             BNE.N    ??denyTask_1
    579          		{
    580          			GPIO_SetBits(GPIOC, GPIO_Pin_10);
   \       0x24   0xF44F 0x6180      MOV      R1,#+1024
   \       0x28   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40011000
   \       0x2A   0x....'....        BL       GPIO_SetBits
    581          			// piezo
    582          			GPIO_SetBits(GPIOB, GPIO_Pin_8);
   \       0x2E   0xF44F 0x7180      MOV      R1,#+256
   \       0x32   0x....             LDR.N    R0,??DataTable12  ;; 0x40010c00
   \       0x34   0x....'....        BL       GPIO_SetBits
    583          		}
    584          		OSSemPend(sem, 0, (INT8U *)&err);
   \                     ??denyTask_1: (+1)
   \       0x38   0x....'....        BL       ?Subroutine4
    585          		if (count == 0)
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0x3C   0x....'....        BL       ?Subroutine8
    586          			count = 1;
    587          		OSSemPost(sem);
    588          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
   \                     ??CrossCallReturnLabel_31: (+1)
   \       0x40   0x....'....        BL       ?Subroutine2
    589          	}
   \                     ??CrossCallReturnLabel_10: (+1)
   \       0x44   0xE7DE             B.N      ??denyTask_0
    590          }
    591          
    592          /*
    593           *********************************************************************************************************
    594           *                                            checkTask()
    595           *
    596           * Description : Check dot-matrix, piezo, motor.
    597           *
    598           * Argument(s) : p
    599           *
    600           * Return(s)   : none.
    601           *
    602           * Caller(s)   : This is a task.
    603           *
    604           * Note(s)     : none.
    605           *********************************************************************************************************
    606           */
    607          // 경고를 일정 시간 후 정지하도록 하는 Task

   \                                 In section .text, align 4, keep-with-next
    608          static void checkTask(void *p)
    609          {
   \                     checkTask: (+1)
   \        0x0   0xB538             PUSH     {R3-R5,LR}
    610          	CPU_INT08U err;
    611          
    612          	BSP_Init();
   \        0x2   0x....'....        BL       BSP_Init
    613          	OS_CPU_SysTickInit();
   \        0x6   0x....'....        BL       OS_CPU_SysTickInit
    614          #if (OS_TASK_STAT_EN > 0)
    615          	OSStatInit(); /* Determine CPU capacity.                              */
   \        0xA   0x....'....        BL       OSStatInit
    616          #endif
    617          
    618          #if ((APP_PROBE_COM_EN == DEF_ENABLED) || \
    619          	 (APP_OS_PROBE_EN == DEF_ENABLED))
    620          	App_InitProbe();
   \        0xE   0x....'....        BL       OSProbe_Init
   \       0x12   0x....'....        ADR.W    R0,App_ProbeCallback
   \       0x16   0x....             LDR.N    R4,??DataTable12_6
   \       0x18   0x....             LDR.N    R5,??DataTable12_1  ;; 0x40011000
   \       0x1A   0x....'....        BL       OSProbe_SetCallback
   \       0x1E   0x20FA             MOVS     R0,#+250
   \       0x20   0x....'....        BL       OSProbe_SetDelay
   \       0x24   0x....'....        BL       ProbeCom_Init
    621          #endif
    622          
    623          	// Create Event Flag
    624          	flagGroup = OSFlagCreate(0, &err);
   \       0x28   0x4669             MOV      R1,SP
   \       0x2A   0x2000             MOVS     R0,#+0
   \       0x2C   0x....'....        BL       OSFlagCreate
   \       0x30   0x6020             STR      R0,[R4, #+0]
    625          
    626          	while (DEF_TRUE)
    627          	{
    628          		
    629          		if (count != 0)
   \                     ??checkTask_0: (+1)
   \       0x32   0x68A0             LDR      R0,[R4, #+8]
   \       0x34   0xB320             CBZ.N    R0,??checkTask_1
    630          		{
    631          			OSSemPend(sem, 0, &err);
   \       0x36   0x6860             LDR      R0,[R4, #+4]
   \       0x38   0x466A             MOV      R2,SP
   \       0x3A   0x....'....        BL       ??Subroutine4_0
    632          			check++;
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x3E   0x68E0             LDR      R0,[R4, #+12]
   \       0x40   0x1C40             ADDS     R0,R0,#+1
   \       0x42   0x60E0             STR      R0,[R4, #+12]
    633          			OSSemPost(sem);
   \       0x44   0x6860             LDR      R0,[R4, #+4]
   \       0x46   0x....'....        BL       OSSemPost
    634          			if (check > 3000000)
   \       0x4A   0x68E0             LDR      R0,[R4, #+12]
   \       0x4C   0x....             LDR.N    R1,??DataTable12_11  ;; 0x2dc6c1
   \       0x4E   0x4288             CMP      R0,R1
   \       0x50   0xDB16             BLT.N    ??checkTask_1
    635          			{
    636          				stopAll();
   \       0x52   0xF44F 0x6100      MOV      R1,#+2048
   \       0x56   0x4628             MOV      R0,R5
   \       0x58   0x....'....        BL       GPIO_ResetBits
   \       0x5C   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0x60   0xF44F 0x7180      MOV      R1,#+256
   \       0x64   0x....             LDR.N    R0,??DataTable12  ;; 0x40010c00
   \       0x66   0x....'....        BL       GPIO_ResetBits
    637          				OSSemPend(sem, 0, &err);
   \       0x6A   0x6860             LDR      R0,[R4, #+4]
   \       0x6C   0x466A             MOV      R2,SP
   \       0x6E   0x....'....        BL       ??Subroutine4_0
    638          				count = 0;
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x72   0x2000             MOVS     R0,#+0
   \       0x74   0x60A0             STR      R0,[R4, #+8]
    639          				OSSemPost(sem);
   \       0x76   0x6860             LDR      R0,[R4, #+4]
   \       0x78   0x....'....        BL       OSSemPost
    640          				check = 0;
   \       0x7C   0x2000             MOVS     R0,#+0
   \       0x7E   0x60E0             STR      R0,[R4, #+12]
    641          			}
    642          		}
    643          
    644          		OSTimeDlyHMSM(0, 0, 1, 0); // To run other tasks
   \                     ??checkTask_1: (+1)
   \       0x80   0x2300             MOVS     R3,#+0
   \       0x82   0x2201             MOVS     R2,#+1
   \       0x84   0x....'....        BL       ??Subroutine2_0
    645          	}
   \                     ??CrossCallReturnLabel_9: (+1)
   \       0x88   0xE7D3             B.N      ??checkTask_0
    646          }
    647          
    648          // Stop all
    649          static void stopAll()
    650          {
    651          	// LED
    652          	GPIO_ResetBits(GPIOC, GPIO_Pin_11);
    653          	GPIO_ResetBits(GPIOC, GPIO_Pin_10);
    654          	// piezo
    655          	GPIO_ResetBits(GPIOB, GPIO_Pin_8);
    656          }
    657          
    658          /*
    659           *********************************************************************************************************
    660           *                                            displayTask()
    661           *
    662           * Description : display with dot-matrix.
    663           *
    664           * Argument(s) : p
    665           *
    666           * Return(s)   : none.
    667           *
    668           * Caller(s)   : This is a task.
    669           *
    670           * Note(s)     : none.
    671           *********************************************************************************************************
    672           */
    673          /*
    674          // dot-matrix 출력
    675          static void
    676          displayTask(void *p)
    677          {
    678          	CPU_INT08U err;
    679          	int color = 0; // green
    680          	int shape = 0; // O
    681          	while (DEF_TRUE)
    682          	{
    683          		GPIO_SetBits(GPIOC, GPIO_Pin_6);
    684          		GPIO_SetBits(GPIOC, GPIO_Pin_8);
    685          		
    686          		for (int i = 0; i < 8; i++)
    687          		{
    688          			GPIO_SetBits(lineTypes[i], linePins[i]);
    689          			for (int j = 0; j < 8; j++)
    690          			{
    691          				GPIO_SetBits(orangeTypes[i], orangePins[j]);
    692          				
    693          				if (shape == 0 && shapeO[i][j] == 1)
    694          				{
    695          
    696          					GPIO_SetBits(orangeTypes[j], orangePins[j]);
    697          				}
    698          				else if (shape == 1 && shapeX[i][j] == 1)
    699          				{
    700          
    701          					GPIO_SetBits(orangeTypes[j], orangePins[j]);
    702          				}
    703          				else
    704          				{
    705          					//GPIO_ResetBits(orangeTypes[j], orangePins[j]);
    706          					//GPIO_ResetBits(greenTypes[j], greenPins[j]);
    707          				}
    708          				
    709          			}
    710          
    711          			GPIO_ResetBits(lineTypes[i], linePins[i]);
    712          		}
    713          		
    714          		OSTimeDlyHMSM(0, 0, 0, 30); // To run other tasks
    715          	}
    716          }
    717          */
    718          /*
    719           *********************************************************************************************************
    720           *                                          App_DispScr_SignOn()
    721           *
    722           * Description : Display uC/OS-II system information on the LCD.
    723           *
    724           * Argument(s) : none.
    725           *
    726           * Return(s)   : none.
    727           *
    728           * Caller(s)   : TaskUserIF().
    729           *
    730           * Note(s)     : none.
    731           *********************************************************************************************************
    732           */
    733          
    734          static void App_DispScr_SignOn(void)
    735          {
    736          }
    737          
    738          /*
    739           *********************************************************************************************************
    740           *                                          App_DispScr_SignOn()
    741           *
    742           * Description : Display uC/OS-II system information on the LCD.
    743           *
    744           * Argument(s) : none.
    745           *
    746           * Return(s)   : none.
    747           *
    748           * Caller(s)   : TaskUserIF().
    749           *
    750           * Note(s)     : none.
    751           *********************************************************************************************************
    752           */
    753          
    754          static void App_DispScr_TaskNames(void)
    755          {
    756          }
    757          
    758          /*
    759           *********************************************************************************************************
    760           *                                             App_InitProbe()
    761           *
    762           * Description : Initialize uC/Probe target code.
    763           *
    764           * Argument(s) : none.
    765           *
    766           * Return(s)   : none.
    767           *
    768           * Caller(s)   : App_TaskStart().
    769           *
    770           * Note(s)     : none.
    771           *********************************************************************************************************
    772           */
    773          
    774          #if ((APP_PROBE_COM_EN == DEF_ENABLED) || \
    775          	 (APP_OS_PROBE_EN == DEF_ENABLED))
    776          static void App_InitProbe(void)
    777          {
    778          #if (APP_OS_PROBE_EN == DEF_ENABLED)
    779          	(void)App_ProbeCounts;
    780          	(void)App_ProbeB1;
    781          
    782          #if ((APP_PROBE_COM_EN == DEF_ENABLED) && \
    783          	 (PROBE_COM_STAT_EN == DEF_ENABLED))
    784          	(void)App_ProbeComRxPktSpd;
    785          	(void)App_ProbeComTxPktSpd;
    786          	(void)App_ProbeComTxSymSpd;
    787          	(void)App_ProbeComTxSymByteSpd;
    788          #endif
    789          
    790          	OSProbe_Init();
    791          	OSProbe_SetCallback(App_ProbeCallback);
    792          	OSProbe_SetDelay(250);
    793          #endif
    794          
    795          #if (APP_PROBE_COM_EN == DEF_ENABLED)
    796          	ProbeCom_Init(); /* Initialize the uC/Probe communications module.       */
    797          #endif
    798          }
    799          #endif
    800          
    801          /*
    802           *********************************************************************************************************
    803           *                                         AppProbeCallback()
    804           *
    805           * Description : uC/Probe OS plugin callback.
    806           *
    807           * Argument(s) : none.
    808           *
    809           * Return(s)   : none.
    810           *
    811           * Caller(s)   : uC/Probe OS plugin task.
    812           *
    813           * Note(s)     : none.
    814           *********************************************************************************************************
    815           */
    816          
    817          #if (APP_OS_PROBE_EN == DEF_ENABLED)

   \                                 In section .text, align 4, keep-with-next
    818          static void App_ProbeCallback(void)
    819          {
   \                     App_ProbeCallback: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    820          #if ((APP_PROBE_COM_EN == DEF_ENABLED) && \
    821          	 (PROBE_COM_STAT_EN == DEF_ENABLED))
    822          	CPU_INT32U ctr_curr;
    823          	CPU_INT32U rxpkt_curr;
    824          	CPU_INT32U txpkt_curr;
    825          	CPU_INT32U sym_curr;
    826          	CPU_INT32U symbyte_curr;
    827          #endif
    828          
    829          	App_ProbeCounts++;
   \        0x2   0x....             LDR.N    R4,??DataTable12_12
   \        0x4   0x6961             LDR      R1,[R4, #+20]
   \        0x6   0x1C49             ADDS     R1,R1,#+1
   \        0x8   0x6161             STR      R1,[R4, #+20]
    830          
    831          	App_ProbeB1 = BSP_PB_GetStatus(1);
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x....'....        BL       BSP_PB_GetStatus
    832          
    833          #if ((APP_PROBE_COM_EN == DEF_ENABLED) && \
    834          	 (PROBE_COM_STAT_EN == DEF_ENABLED))
    835          	ctr_curr = OSTime;
   \       0x10   0x....             LDR.N    R1,??DataTable12_13
   \       0x12   0x6808             LDR      R0,[R1, #+0]
    836          	rxpkt_curr = ProbeCom_RxPktCtr;
    837          	txpkt_curr = ProbeCom_TxPktCtr;
    838          	sym_curr = ProbeCom_TxSymCtr;
    839          	symbyte_curr = ProbeCom_TxSymByteCtr;
    840          
    841          	if ((ctr_curr - App_ProbeComCtrLast) >= OS_TICKS_PER_SEC)
   \       0x14   0x6922             LDR      R2,[R4, #+16]
   \       0x16   0x1A82             SUBS     R2,R0,R2
   \       0x18   0xF5B2 0x7F7A      CMP      R2,#+1000
   \       0x1C   0xD30C             BCC.N    ??App_ProbeCallback_0
    842          	{
    843          		App_ProbeComRxPktSpd = ((CPU_FP32)(rxpkt_curr - App_ProbeComRxPktLast) / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    844          		App_ProbeComTxPktSpd = ((CPU_FP32)(txpkt_curr - App_ProbeComTxPktLast) / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    845          		App_ProbeComTxSymSpd = ((CPU_FP32)(sym_curr - App_ProbeComTxSymLast) / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    846          		App_ProbeComTxSymByteSpd = ((CPU_FP32)(symbyte_curr - App_ProbeComTxSymByteLast) / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    847          
    848          		App_ProbeComCtrLast = ctr_curr;
   \       0x1E   0x6120             STR      R0,[R4, #+16]
    849          		App_ProbeComRxPktLast = rxpkt_curr;
    850          		App_ProbeComTxPktLast = txpkt_curr;
   \       0x20   0x....             LDR.N    R2,??DataTable12_14
   \       0x22   0x....             LDR.N    R0,??DataTable12_15
   \       0x24   0x6801             LDR      R1,[R0, #+0]
    851          		App_ProbeComTxSymLast = sym_curr;
   \       0x26   0x....             LDR.N    R0,??DataTable12_16
   \       0x28   0x6021             STR      R1,[R4, #+0]
   \       0x2A   0x6813             LDR      R3,[R2, #+0]
    852          		App_ProbeComTxSymByteLast = symbyte_curr;
   \       0x2C   0x....             LDR.N    R2,??DataTable12_17
   \       0x2E   0x6063             STR      R3,[R4, #+4]
   \       0x30   0x6801             LDR      R1,[R0, #+0]
   \       0x32   0x60A1             STR      R1,[R4, #+8]
   \       0x34   0x6810             LDR      R0,[R2, #+0]
   \       0x36   0x60E0             STR      R0,[R4, #+12]
    853          	}
    854          #endif
    855          }
   \                     ??App_ProbeCallback_0: (+1)
   \       0x38   0xBD10             POP      {R4,PC}          ;; return
    856          #endif
    857          
    858          /*
    859           *********************************************************************************************************
    860           *                                      App_FormatDec()
    861           *
    862           * Description : Convert a decimal value to ASCII (without leading zeros).
    863           *
    864           * Argument(s) : pstr            Pointer to the destination ASCII string.
    865           *
    866           *               value           Value to convert (assumes an unsigned value).
    867           *
    868           *               digits          The desired number of digits.
    869           *
    870           * Return(s)   : none.
    871           *
    872           * Caller(s)   : various.
    873           *
    874           * Note(s)     : none.
    875           *********************************************************************************************************
    876           */
    877          
    878          /*
    879           *********************************************************************************************************
    880           *********************************************************************************************************
    881           *                                          uC/OS-II APP HOOKS
    882           *********************************************************************************************************
    883           *********************************************************************************************************
    884           */
    885          
    886          #if (OS_APP_HOOKS_EN > 0)
    887          /*
    888           *********************************************************************************************************
    889           *                                      TASK CREATION HOOK (APPLICATION)
    890           *
    891           * Description : This function is cal when a task is created.
    892           *
    893           * Argument(s) : ptcb   is a pointer to the task control block of the task being created.
    894           *
    895           * Note(s)     : (1) Interrupts are disabled during this call.
    896           *********************************************************************************************************
    897           */
    898          

   \                                 In section .text, align 2, keep-with-next
    899          void App_TaskCreateHook(OS_TCB *ptcb)
    900          {
    901          #if ((APP_OS_PROBE_EN == DEF_ENABLED) && \
    902          	 (OS_PROBE_HOOKS_EN == DEF_ENABLED))
    903          	OSProbe_TaskCreateHook(ptcb);
   \                     App_TaskCreateHook: (+1)
   \        0x0   0x....'....        B.W      OSProbe_TaskCreateHook
    904          #endif
    905          }
    906          
    907          /*
    908           *********************************************************************************************************
    909           *                                    TASK DELETION HOOK (APPLICATION)
    910           *
    911           * Description : This function is called when a task is deleted.
    912           *
    913           * Argument(s) : ptcb   is a pointer to the task control block of the task being deleted.
    914           *
    915           * Note(s)     : (1) Interrupts are disabled during this call.
    916           *********************************************************************************************************
    917           */
    918          

   \                                 In section .text, align 2, keep-with-next
    919          void App_TaskDelHook(OS_TCB *ptcb)
    920          {
    921          	(void)ptcb;
    922          }
   \                     App_TaskDelHook: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    923          
    924          /*
    925           *********************************************************************************************************
    926           *                                      IDLE TASK HOOK (APPLICATION)
    927           *
    928           * Description : This function is called by OSTaskIdleHook(), which is called by the idle task.  This hook
    929           *               has been added to allow you to do such things as STOP the CPU to conserve power.
    930           *
    931           * Argument(s) : none.
    932           *
    933           * Note(s)     : (1) Interrupts are enabled during this call.
    934           *********************************************************************************************************
    935           */
    936          
    937          #if OS_VERSION >= 251

   \                                 In section .text, align 2, keep-with-next
    938          void App_TaskIdleHook(void)
    939          {
    940          }
   \                     App_TaskIdleHook: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    941          #endif
    942          
    943          /*
    944           *********************************************************************************************************
    945           *                                        STATISTIC TASK HOOK (APPLICATION)
    946           *
    947           * Description : This function is called by OSTaskStatHook(), which is called every second by uC/OS-II's
    948           *               statistics task.  This allows your application to add functionality to the statistics task.
    949           *
    950           * Argument(s) : none.
    951           *********************************************************************************************************
    952           */
    953          

   \                                 In section .text, align 2, keep-with-next
    954          void App_TaskStatHook(void)
    955          {
    956          }
   \                     App_TaskStatHook: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    957          
    958          /*
    959           *********************************************************************************************************
    960           *                                        TASK SWITCH HOOK (APPLICATION)
    961           *
    962           * Description : This function is called when a task switch is performed.  This allows you to perform other
    963           *               operations during a context switch.
    964           *
    965           * Argument(s) : none.
    966           *
    967           * Note(s)     : (1) Interrupts are disabled during this call.
    968           *
    969           *               (2) It is assumed that the global pointer 'OSTCBHighRdy' points to the TCB of the task that
    970           *                   will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
    971           *                  task being switched out (i.e. the preempted task).
    972           *********************************************************************************************************
    973           */
    974          
    975          #if OS_TASK_SW_HOOK_EN > 0

   \                                 In section .text, align 2, keep-with-next
    976          void App_TaskSwHook(void)
    977          {
    978          #if ((APP_OS_PROBE_EN == DEF_ENABLED) && \
    979          	 (OS_PROBE_HOOKS_EN == DEF_ENABLED))
    980          	OSProbe_TaskSwHook();
   \                     App_TaskSwHook: (+1)
   \        0x0   0x....'....        B.W      OSProbe_TaskSwHook
    981          #endif
    982          }
    983          #endif
    984          
    985          /*
    986           *********************************************************************************************************
    987           *                                     OS_TCBInit() HOOK (APPLICATION)
    988           *
    989           * Description : This function is called by OSTCBInitHook(), which is called by OS_TCBInit() after setting
    990           *               up most of the TCB.
    991           *
    992           * Argument(s) : ptcb    is a pointer to the TCB of the task being created.
    993           *
    994           * Note(s)     : (1) Interrupts may or may not be ENABLED during this call.
    995           *********************************************************************************************************
    996           */
    997          
    998          #if OS_VERSION >= 204

   \                                 In section .text, align 2, keep-with-next
    999          void App_TCBInitHook(OS_TCB *ptcb)
   1000          {
   1001          	(void)ptcb;
   1002          }
   \                     App_TCBInitHook: (+1)
   \        0x0   0x4770             BX       LR               ;; return
   1003          #endif
   1004          
   1005          /*
   1006           *********************************************************************************************************
   1007           *                                        TICK HOOK (APPLICATION)
   1008           *
   1009           * Description : This function is called every tick.
   1010           *
   1011           * Argument(s) : none.
   1012           *
   1013           * Note(s)     : (1) Interrupts may or may not be ENABLED during this call.
   1014           *********************************************************************************************************
   1015           */
   1016          
   1017          #if OS_TIME_TICK_HOOK_EN > 0

   \                                 In section .text, align 2, keep-with-next
   1018          void App_TimeTickHook(void)
   1019          {
   1020          #if ((APP_OS_PROBE_EN == DEF_ENABLED) && \
   1021          	 (OS_PROBE_HOOKS_EN == DEF_ENABLED))
   1022          	OSProbe_TickHook();
   \                     App_TimeTickHook: (+1)
   \        0x0   0x....'....        B.W      OSProbe_TickHook
   1023          #endif
   1024          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \        0x4   0xF88D 0x1003      STRB     R1,[SP, #+3]
   \        0x8   0x2203             MOVS     R2,#+3
   \        0xA   0xF88D 0x2002      STRB     R2,[SP, #+2]
   \        0xE   0x4669             MOV      R1,SP
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \        0x4   0xF88D 0x1003      STRB     R1,[SP, #+3]
   \        0x8   0x2203             MOVS     R2,#+3
   \        0xA   0xF88D 0x2002      STRB     R2,[SP, #+2]
   \        0xE   0x4669             MOV      R1,SP
   \       0x10   0x4620             MOV      R0,R4
   \       0x12   0x....'....        B.W      GPIO_Init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \        0x0   0x4001'0C00        DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \        0x0   0x4001'1000        DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \        0x0   0x4001'2400        DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \        0x0   0x0001'86A0        DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \        0x0   0x4000'5400        DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \        0x0   0x4000'3800        DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \        0x0   0x....'....        DC32     flagGroup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \        0x0   0x0003'0001        DC32     0x30001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \        0x0   0x0007'0082        DC32     0x70082

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \        0x0   0x0007'0084        DC32     0x70084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \        0x0   0x0003'0002        DC32     0x30002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \        0x0   0x002D'C6C1        DC32     0x2dc6c1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \        0x0   0x....'....        DC32     App_ProbeComRxPktLast

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_13:
   \        0x0   0x....'....        DC32     OSTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_14:
   \        0x0   0x....'....        DC32     ProbeCom_TxPktCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_15:
   \        0x0   0x....'....        DC32     ProbeCom_RxPktCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_16:
   \        0x0   0x....'....        DC32     ProbeCom_TxSymCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_17:
   \        0x0   0x....'....        DC32     ProbeCom_TxSymByteCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x44 0x65          DC8 "Detect Task"

   \              0x74 0x65    

   \              0x63 0x74    

   \              0x20 0x54    

   \              0x61 0x73    

   \              0x6B 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x54 0x65          DC8 "Temperature Task"

   \              0x6D 0x70    

   \              0x65 0x72    

   \              0x61 0x74    

   \              0x75 0x72    

   \              0x65 0x20    

   \              0x54 0x61    

   \              0x73 0x6B    

   \              0x00
   \       0x11                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x50 0x61          DC8 "Pass Task"

   \              0x73 0x73    

   \              0x20 0x54    

   \              0x61 0x73    

   \              0x6B 0x00
   \        0xA                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x44 0x65          DC8 "Deny Task"

   \              0x6E 0x79    

   \              0x20 0x54    

   \              0x61 0x73    

   \              0x6B 0x00
   \        0xA                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \        0x0   0x43 0x68          DC8 "Check Task"

   \              0x65 0x63    

   \              0x6B 0x20    

   \              0x54 0x61    

   \              0x73 0x6B    

   \              0x00
   \        0xB                      DS8 1
   1025          #endif
   1026          #endif
   1027          
   1028          static void initAll()
   1029          {
   1030          	ADC_InitTypeDef adc_init;
   1031          	GPIO_InitTypeDef gpio_init;
   1032          	I2C_InitTypeDef i2c_init;
   1033          	SPI_InitTypeDef spi_init;
   1034          
   1035          	// CLOCK
   1036          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
   1037          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
   1038          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
   1039          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
   1040          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
   1041          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
   1042          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
   1043          
   1044          	// PIN
   1045          	// ADC / 온도
   1046          	gpio_init.GPIO_Pin = GPIO_Pin_0;
   1047          	gpio_init.GPIO_Mode = GPIO_Mode_AIN;
   1048          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   1049          	GPIO_Init(GPIOB, &gpio_init);
   1050          	// 인체 감지
   1051          	gpio_init.GPIO_Pin = GPIO_Pin_1;
   1052          	gpio_init.GPIO_Mode = GPIO_Mode_AIN;
   1053          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   1054          	GPIO_Init(GPIOB, &gpio_init);
   1055          	// I2C
   1056          	gpio_init.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
   1057          	gpio_init.GPIO_Mode = GPIO_Mode_AF_OD;
   1058          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   1059          	GPIO_Init(GPIOB, &gpio_init);
   1060          	// Piezo
   1061          	gpio_init.GPIO_Pin = GPIO_Pin_8;
   1062          	gpio_init.GPIO_Mode = GPIO_Mode_Out_PP;
   1063          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   1064          	GPIO_Init(GPIOB, &gpio_init);
   1065          	// SPI
   1066          	gpio_init.GPIO_Pin = GPIO_Pin_12;
   1067          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   1068          	gpio_init.GPIO_Mode = GPIO_Mode_Out_PP;
   1069          	GPIO_Init(GPIOB, &gpio_init);
   1070          	gpio_init.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
   1071          	gpio_init.GPIO_Mode = GPIO_Mode_AF_PP;
   1072          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   1073          	GPIO_Init(GPIOB, &gpio_init);
   1074          
   1075          	// light
   1076          	gpio_init.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_10;
   1077          	gpio_init.GPIO_Mode = GPIO_Mode_Out_PP;
   1078          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   1079          	GPIO_Init(GPIOC, &gpio_init);
   1080          
   1081          	/*
   1082          	// dot-matrix
   1083          	gpio_init.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
   1084          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   1085          	gpio_init.GPIO_Mode = GPIO_Mode_Out_PP;
   1086          	GPIO_Init(GPIOA, &gpio_init);
   1087          
   1088          	gpio_init.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_0;
   1089          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   1090          	gpio_init.GPIO_Mode = GPIO_Mode_Out_PP;
   1091          	GPIO_Init(GPIOB, &gpio_init);
   1092          
   1093          	gpio_init.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9;
   1094          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   1095          	gpio_init.GPIO_Mode = GPIO_Mode_Out_PP;
   1096          	GPIO_Init(GPIOC, &gpio_init);
   1097          */
   1098          	/*
   1099          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
   1100            	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   1101            	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   1102            	GPIO_Init(GPIOD, &GPIO_InitStructure);
   1103          */
   1104          	// CONFIG
   1105          	// ADC
   1106          	adc_init.ADC_Mode = ADC_Mode_Independent;
   1107          	adc_init.ADC_ScanConvMode = ENABLE;
   1108          	adc_init.ADC_ContinuousConvMode = ENABLE;
   1109          	adc_init.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
   1110          	adc_init.ADC_DataAlign = ADC_DataAlign_Right;
   1111          	adc_init.ADC_NbrOfChannel = 2;
   1112          	ADC_Init(ADC1, &adc_init);
   1113          	ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 1, ADC_SampleTime_41Cycles5);
   1114          	//ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE);
   1115          	ADC_Cmd(ADC1, ENABLE);
   1116          
   1117          	ADC_ResetCalibration(ADC1);
   1118          	while (ADC_GetResetCalibrationStatus(ADC1) != RESET)
   1119          		;
   1120          	ADC_StartCalibration(ADC1);
   1121          	while (ADC_GetCalibrationStatus(ADC1) != RESET)
   1122          		;
   1123          	ADC_SoftwareStartConvCmd(ADC1, ENABLE);
   1124          
   1125          	// I2C
   1126          	i2c_init.I2C_Mode = I2C_Mode_I2C;
   1127          	i2c_init.I2C_DutyCycle = I2C_DutyCycle_2;
   1128          	i2c_init.I2C_OwnAddress1 = 0;
   1129          	i2c_init.I2C_Ack = I2C_Ack_Enable;
   1130          	i2c_init.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   1131          	i2c_init.I2C_ClockSpeed = 100000;
   1132          	I2C_Init(((I2C_TypeDef *)I2C1_BASE), &i2c_init);
   1133          	I2C_Cmd(((I2C_TypeDef *)I2C1_BASE), ENABLE);
   1134          	// SPI
   1135          	spi_init.SPI_Direction = SPI_Direction_1Line_Tx;
   1136          	spi_init.SPI_Mode = SPI_Mode_Master;
   1137          	spi_init.SPI_DataSize = SPI_DataSize_16b;
   1138          	spi_init.SPI_CPOL = SPI_CPOL_Low;
   1139          	spi_init.SPI_CPHA = SPI_CPHA_1Edge;
   1140          	spi_init.SPI_NSS = SPI_NSS_Soft;
   1141          	spi_init.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
   1142          	spi_init.SPI_FirstBit = SPI_FirstBit_MSB;
   1143          	spi_init.SPI_CRCPolynomial;
   1144          	SPI_Init(SPI2, &spi_init);
   1145          	SPI_Cmd(SPI2, ENABLE);
   1146          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   App_ProbeCallback
         8   -> BSP_PB_GetStatus
       0   App_TCBInitHook
       0   App_TaskCreateHook
         0   -> OSProbe_TaskCreateHook
       0   App_TaskDelHook
       0   App_TaskIdleHook
       0   App_TaskStatHook
       0   App_TaskSwHook
         0   -> OSProbe_TaskSwHook
       0   App_TimeTickHook
         0   -> OSProbe_TickHook
      16   checkTask
        16   -> BSP_Init
        16   -> GPIO_ResetBits
        16   -> OSFlagCreate
        16   -> OSProbe_Init
        16   -> OSProbe_SetCallback
        16   -> OSProbe_SetDelay
        16   -> OSSemPend
        16   -> OSSemPost
        16   -> OSStatInit
        16   -> OSTimeDlyHMSM
        16   -> OS_CPU_SysTickInit
        16   -> ProbeCom_Init
      16   denyTask
        16   -> GPIO_SetBits
        16   -> OSFlagPend
        16   -> OSSemPend
        16   -> OSSemPost
        16   -> OSTimeDlyHMSM
       8   detectTask
         8   -> GPIO_ReadInputDataBit
         8   -> OSFlagPost
         8   -> OSTimeDlyHMSM
      32   i2c_multi_read
         0   -> I2C_AcknowledgeConfig
        32   -> I2C_AcknowledgeConfig
        32   -> I2C_CheckEvent
        32   -> I2C_GenerateSTART
        32   -> I2C_GenerateSTOP
        32   -> I2C_GetFlagStatus
        32   -> I2C_GetLastEvent
        32   -> I2C_ReceiveData
        32   -> I2C_Send7bitAddress
        32   -> I2C_SendData
      80   main
        80   -> ADC_Cmd
        80   -> ADC_GetCalibrationStatus
        80   -> ADC_GetResetCalibrationStatus
        80   -> ADC_Init
        80   -> ADC_RegularChannelConfig
        80   -> ADC_ResetCalibration
        80   -> ADC_SoftwareStartConvCmd
        80   -> ADC_StartCalibration
        80   -> BSP_IntDisAll
        80   -> GPIO_Init
        80   -> GPIO_ResetBits
        80   -> GPIO_SetBits
        80   -> I2C_Cmd
        80   -> I2C_Init
        80   -> OSInit
        80   -> OSSemCreate
        80   -> OSStart
        80   -> OSTaskCreateExt
        80   -> OSTaskNameSet
        80   -> RCC_APB1PeriphClockCmd
        80   -> RCC_APB2PeriphClockCmd
        80   -> SPI_Cmd
        80   -> SPI_Init
      16   passTask
        16   -> OSFlagPend
        16   -> OSSemPend
        16   -> OSSemPost
        16   -> OSTimeDlyHMSM
      16   temperTask
        16   -> OSFlagPost
        16   -> OSTimeDlyHMSM


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_13
       4  ??DataTable12_14
       4  ??DataTable12_15
       4  ??DataTable12_16
       4  ??DataTable12_17
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
      22  ?Subroutine0
      12  ?Subroutine1
      12  ?Subroutine2
      18  ?Subroutine3
      10  ?Subroutine4
      12  ?Subroutine5
       8  ?Subroutine6
      10  ?Subroutine7
      14  ?Subroutine8
      12  ?_0
      20  ?_1
      12  ?_2
      12  ?_3
      12  ?_4
       1  App_ProbeB1
      58  App_ProbeCallback
      24  App_ProbeComRxPktLast
          App_ProbeComTxPktLast
          App_ProbeComTxSymLast
          App_ProbeComTxSymByteLast
          App_ProbeComCtrLast
          App_ProbeCounts
       4  App_ProbeComRxPktSpd
       4  App_ProbeComTxPktSpd
       4  App_ProbeComTxSymByteSpd
       4  App_ProbeComTxSymSpd
       2  App_TCBInitHook
       4  App_TaskCreateHook
       2  App_TaskDelHook
       2  App_TaskIdleHook
       2  App_TaskStatHook
       4  App_TaskSwHook
       4  App_TimeTickHook
     138  checkTask
      70  denyTask
      38  detectTask
   1'296  flagGroup
          sem
          count
          check
          detectTaskStack
          temperatureTaskStack
          passTaskStack
          denyTaskStack
          checkTaskStack
     190  i2c_multi_read
     674  main
      34  passTask
      22  temperTask

 
 1'337 bytes in section .bss
 1'502 bytes in section .text
 
 1'502 bytes of CODE memory
 1'337 bytes of DATA memory

Errors: none
Warnings: 14
