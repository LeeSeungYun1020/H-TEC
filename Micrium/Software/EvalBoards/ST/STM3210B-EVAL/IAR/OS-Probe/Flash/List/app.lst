###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Dec/2020  03:31:11
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\app.c
#    Command line                 =
#        -f C:\Users\fabi8\AppData\Local\Temp\EWE5F9.tmp
#        (D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\app.c
#        -lCN
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List
#        -o
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "D:\Develop\IAR Systems\arm\inc\c\DLib_Config_Normal.h" -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\ports\arm-cortex-m3\generic\iar\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\source\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-lib\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\ARM-Cortex-M3\IAR\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\cpu\st\stm32\inc\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\BSP\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II\\
#        -Ohz --use_c++_inline)
#    Locale                       =  C
#    List file                    =
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List\app.lst
#    Object file                  =
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj\app.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#      __size_limit               =  32768|ARM.EW.LINKER
#
###############################################################################

D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\app.c
      1          /*
      2           *********************************************************************************************************
      3           *                                              TERM PROJECT
      4           *                          (C) Copyright 2020; Lee Seung Yun; Shim Jae Yeong
      5           *               Some codes are referenced below.
      6           * 
      7           *                                              EXAMPLE CODE
      8           *
      9           *                          (c) Copyright 2003-2006; Micrium, Inc.; Weston, FL
     10           *
     11           *               All rights reserved.  Protected by international copyright laws.
     12           *               Knowledge of the source code may NOT be used to develop a similar product.
     13           *               Please help us continue to provide the Embedded community with the finest
     14           *               software available.  Your honesty is greatly appreciated.
     15           *********************************************************************************************************
     16           */
     17          
     18          /*
     19           *********************************************************************************************************
     20           *
     21           *                             High Temperature Entrance Checking Technique
     22           *
     23           *                                     ST Microelectronics STM32
     24           *                                              with the
     25           *                                   STM3210B-EVAL Evaluation Board
     26           *
     27           * Filename      : app.c
     28           * Version       : V1.0
     29           * Programmer(s) : Lee Seung Yun, Shim Jae Yeong
     30           *********************************************************************************************************
     31           */
     32          
     33          /*
     34           *********************************************************************************************************
     35           *                                             INCLUDE FILES
     36           *********************************************************************************************************
     37           */
     38          
     39          #include <includes.h>
     40          
     41          /*
     42           *********************************************************************************************************
     43           *                                            LOCAL DEFINES
     44           *********************************************************************************************************
     45           */
     46          
     47          #define MANUAL
     48          //#define AUTO
     49          
     50          /*
     51           *********************************************************************************************************
     52           *                                       LOCAL GLOBAL VARIABLES
     53           *********************************************************************************************************
     54           */
     55          
     56          // Task Stack (size: 128)
     57          static OS_STK detectTaskStack[TASK_STK_SIZE];
     58          static OS_STK temperatureTaskStack[TASK_STK_SIZE];
     59          static OS_STK passTaskStack[TASK_STK_SIZE];
     60          static OS_STK denyTaskStack[TASK_STK_SIZE];
     61          static OS_STK checkTaskStack[TASK_STK_SIZE];
     62          static OS_STK startTaskStack[TASK_STK_SIZE];
     63          
     64          // Event Flags
     65          static OS_FLAG_GRP *flagGroup;
     66          const static int FLAG_INIT = 0;
     67          const static int FLAG_DETECT = 1;
     68          const static int FLAG_DETECT_NOT = 2;
     69          const static int FLAG_TEMPER_NORMAL = 4;
     70          const static int FLAG_TEMPER_HIGH = 8;
     71          const static int FLAG_TEMPER_LOW = 16;
     72          
     73          // Que
     74          static OS_EVENT *tempQue;
     75          static void *tempBuffer[10];
     76          
     77          // time
     78          //static OS_EVENT *sem;
     79          static int count = 0;
     80          static int check = 0;
     81          const static int DELAY_TIME = 1000;
     82          
     83          static int ADC_value = 0;
     84          
     85          #if ((APP_OS_PROBE_EN == DEF_ENABLED) &&  \
     86          	 (APP_PROBE_COM_EN == DEF_ENABLED) && \
     87          	 (PROBE_COM_STAT_EN == DEF_ENABLED))
     88          static CPU_FP32 App_ProbeComRxPktSpd;
     89          static CPU_FP32 App_ProbeComTxPktSpd;
     90          static CPU_FP32 App_ProbeComTxSymSpd;
     91          static CPU_FP32 App_ProbeComTxSymByteSpd;
     92          
     93          static CPU_INT32U App_ProbeComRxPktLast;
     94          static CPU_INT32U App_ProbeComTxPktLast;
     95          static CPU_INT32U App_ProbeComTxSymLast;
     96          static CPU_INT32U App_ProbeComTxSymByteLast;
     97          
     98          static CPU_INT32U App_ProbeComCtrLast;
     99          #endif
    100          
    101          #if (APP_OS_PROBE_EN == DEF_ENABLED)
    102          static CPU_INT32U App_ProbeCounts;
    103          static CPU_BOOLEAN App_ProbeB1;
    104          
    105          #endif
    106          
    107          /*
    108           *********************************************************************************************************
    109           *                                      LOCAL FUNCTION PROTOTYPES
    110           *********************************************************************************************************
    111           */
    112          
    113          // Task function
    114          static void detectTask(void *p);
    115          static void temperTask(void *p);
    116          static void passTask(void *p);
    117          static void denyTask(void *p);
    118          static void checkTask(void *p);
    119          static void startTask(void *p);
    120          
    121          static void App_DispScr_SignOn(void);
    122          static void DispScr_TaskNames(void);
    123          
    124          static int readTemperature(void);
    125          static void stopAlert();
    126          static void startAlert();
    127          static void stopNotice();
    128          static void startNotice();
    129          static void initAll();
    130          
    131          #if ((APP_PROBE_COM_EN == DEF_ENABLED) || \
    132          	 (APP_OS_PROBE_EN == DEF_ENABLED))
    133          static void App_InitProbe(void);
    134          #endif
    135          
    136          #if (APP_OS_PROBE_EN == DEF_ENABLED)
    137          static void App_ProbeCallback(void);
    138          #endif
    139          
    140          /*
    141           *********************************************************************************************************
    142           *                                                main()
    143           *
    144           * Description : This is the standard entry point for C code.  It is assumed that your code will call
    145           *               main() once you have performed all necessary initialization.
    146           *
    147           * Argument(s) : none.
    148           *
    149           * Return(s)   : none.
    150           *********************************************************************************************************
    151           */
    152          
    153          int main(void)
    154          {
    155          	CPU_INT08U os_err;
    156          
    157          	/* Disable all ints until we are ready to accept them.  */
    158          	BSP_IntDisAll();
    159          
    160          	/* Initialize "uC/OS-II, The Real-Time Kernel".         */
    161          	OSInit();
    162          
    163          	initAll();
    164          
    165          	os_err = OSTaskCreateExt((void (*)(void *))detectTask,						   // Task가 수행할 함수, 사람의 존재 유/무를 알려주는 Task
    166          							 (void *)0,											   // Task로 넘겨줄 인자
    167          							 (OS_STK *)&detectTaskStack[TASK_STK_SIZE - 1],		   // Task가 할당될 Stack의 Top을 가리키는 주소
    168          							 (INT8U)TASK_DETECT_PRIO,							   // Task의 우선 순위 (MPT)
    169          							 (INT16U)TASK_DETECT_PRIO,							   // Task를 지칭하는 유일한 식별자, Task 갯수의 극복을 위해서 사용할 예정, 현재는 우선 순위와 같게끔 설정
    170          							 (OS_STK *)&detectTaskStack,						   // Task가 할당될 Stack의 마지막을 가리키는 주소, Stack 검사용으로 사용
    171          							 (INT32U)TASK_STK_SIZE,								   // Task Stack의 크기를 의미
    172          							 (void *)0,											   // Task Control Block 활용시 사용
    173          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK)); // Task 생성 옵션
    174          
    175          	os_err = OSTaskCreateExt((void (*)(void *))temperTask, // 사람의 온도를 측정하여 통과할지 말지를 결정하는 Task
    176          							 (void *)0,
    177          							 (OS_STK *)&temperatureTaskStack[TASK_STK_SIZE - 1],
    178          							 (INT8U)TASK_TEMPER_PRIO,
    179          							 (INT16U)TASK_TEMPER_PRIO,
    180          							 (OS_STK *)&temperatureTaskStack,
    181          							 (INT32U)TASK_STK_SIZE,
    182          							 (void *)0,
    183          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
    184          
    185          	os_err = OSTaskCreateExt((void (*)(void *))passTask, // 정상체온인 사람은 통과를 허가하는 Task
    186          							 (void *)0,
    187          							 (OS_STK *)&passTaskStack[TASK_STK_SIZE - 1],
    188          							 (INT8U)TASK_PASS_PRIO,
    189          							 (INT16U)TASK_PASS_PRIO,
    190          							 (OS_STK *)&passTaskStack,
    191          							 (INT32U)TASK_STK_SIZE,
    192          							 (void *)0,
    193          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
    194          
    195          	os_err = OSTaskCreateExt((void (*)(void *))denyTask, // 비정상체온인 사람은 통과를 불허하는 Task
    196          							 (void *)0,
    197          							 (OS_STK *)&denyTaskStack[TASK_STK_SIZE - 1],
    198          							 (INT8U)TASK_DENY_PRIO,
    199          							 (INT16U)TASK_DENY_PRIO,
    200          							 (OS_STK *)&denyTaskStack,
    201          							 (INT32U)TASK_STK_SIZE,
    202          							 (void *)0,
    203          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
    204          
    205          	os_err = OSTaskCreateExt((void (*)(void *))checkTask, // 알림 장치 작동 중지하는 Task
    206          							 (void *)0,
    207          							 (OS_STK *)&checkTaskStack[TASK_STK_SIZE - 1],
    208          							 (INT8U)TASK_CHECK_PRIO,
    209          							 (INT16U)TASK_CHECK_PRIO,
    210          							 (OS_STK *)&checkTaskStack,
    211          							 (INT32U)TASK_STK_SIZE,
    212          							 (void *)0,
    213          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
    214          
    215          	os_err = OSTaskCreateExt((void (*)(void *))startTask, // 초기화 일회용 Task
    216          							 (void *)0,
    217          							 (OS_STK *)&startTaskStack[TASK_STK_SIZE - 1],
    218          							 (INT8U)TASK_START_PRIO,
    219          							 (INT16U)TASK_START_PRIO,
    220          							 (OS_STK *)startTaskStack,
    221          							 (INT32U)TASK_STK_SIZE,
    222          							 (void *)0,
    223          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
    224          
    225          /*	os_err = OSTaskCreateExt((void (*)(void *))displayTask, // dot-matrix 표시하는 Task
    226          							 (void *)0,
    227          							 (OS_STK *)&displayTaskStack[TASK_STK_SIZE - 1],
    228          							 (INT8U)TASK_DISPLAY_PRIO,
    229          							 (INT16U)TASK_DISPLAY_PRIO,
    230          							 (OS_STK *)&displayTaskStack,
    231          							 (INT32U)TASK_STK_SIZE,
    232          							 (void *)0,
    233          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
    234          */
    235          #if (OS_TASK_NAME_SIZE >= 11)
    236          	OSTaskNameSet(TASK_DETECT_PRIO, (CPU_INT08U *)"Detect Task", &os_err);
    237          	OSTaskNameSet(TASK_TEMPER_PRIO, (CPU_INT08U *)"Temperature Task", &os_err);
    238          	OSTaskNameSet(TASK_PASS_PRIO, (CPU_INT08U *)"Pass Task", &os_err);
    239          	OSTaskNameSet(TASK_DENY_PRIO, (CPU_INT08U *)"Deny Task", &os_err);
    240          	OSTaskNameSet(TASK_CHECK_PRIO, (CPU_INT08U *)"Check Task", &os_err);
    241          	OSTaskNameSet(TASK_START_PRIO, (CPU_INT08U *)"Start Task", &os_err);
    242          	//OSTaskNameSet(TASK_DISPLAY_PRIO, (CPU_INT08U *)"Display Task", &os_err);
    243          #endif
    244          
    245          	OSStart(); /* Start multitasking (i.e. give control to uC/OS-II).  */
    246          
    247          	return (0);
    248          }
    249          
    250          /*
    251           *********************************************************************************************************
    252           *                                          detectTask()
    253           *
    254           * Description : Human detecting task. Monitor the existence of people,
    255           *
    256           * Argument(s) : p
    257           *
    258           * Return(s)   : none.
    259           *
    260           * Caller(s)   : This is a task.
    261           *
    262           * Note(s)     : none.
    263           *********************************************************************************************************
    264           */
    265          
    266          // Task가 수행할 함수, 사람의 존재 유/무를 알려주는 Task
    267          static void detectTask(void *p)
    268          {
    269          	CPU_INT08U err;
    270          
    271          	while (DEF_TRUE)
    272          	{
    273          #ifdef AUTO
    274          		int val = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1);
    275          #endif
    276          #ifdef MANUAL
    277          		int val = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_7);
    278          #endif
    279          		if (val == Bit_RESET) // when human detected(auto) or touch button(manual)
    280          		{
    281          			OSFlagPost(flagGroup, (OS_FLAGS)FLAG_DETECT, OS_FLAG_SET, &err);
    282          		}
    283          		else
    284          		{
    285          			OSFlagPost(flagGroup, (OS_FLAGS)FLAG_DETECT_NOT, OS_FLAG_SET, &err);
    286          		}
    287          		// test
    288          		stopAlert();
    289          		if (val != 0)
    290          		{
    291          			stopNotice();
    292          		}
    293          
    294          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
    295          	}
    296          }
    297          
    298          /*
    299           *********************************************************************************************************
    300           *                                            temperTask()
    301           *
    302           * Description : Measure a person's temperature
    303           *
    304           * Argument(s) : p
    305           *
    306           * Return(s)   : none.
    307           *
    308           * Caller(s)   : This is a task.
    309           *
    310           * Note(s)     : none.
    311           *********************************************************************************************************
    312           */
    313          
    314          // 사람의 온도를 측정하여 통과할지 말지를 결정하는 Task
    315          static void temperTask(void *p)
    316          {
    317          	INT8U err;
    318          	int temp;
    319          	int high = 40;
    320          	int low = 20;
    321          	while (DEF_TRUE)
    322          	{
    323          		temp = 30; // readTemperature()
    324          
    325          		if (temp > high)
    326          		{
    327          			OSFlagPost(flagGroup, (OS_FLAGS)FLAG_TEMPER_HIGH, OS_FLAG_SET, &err);
    328          		}
    329          		else if (temp < low)
    330          		{
    331          			OSFlagPost(flagGroup, (OS_FLAGS)FLAG_TEMPER_LOW, OS_FLAG_SET, &err);
    332          		}
    333          		else
    334          		{
    335          			OSFlagPost(flagGroup, (OS_FLAGS)FLAG_TEMPER_NORMAL, OS_FLAG_SET, &err);
    336          		}
    337          
    338          		//OSQPost(tempQue, (void *)temp);
    339          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
    340          	}
    341          }
    342          static int readTemperature()
    343          {
    344          	while (I2C_GetFlagStatus(((I2C_TypeDef *)I2C1_BASE), I2C_FLAG_BUSY))
    345          		I2C_GenerateSTART(((I2C_TypeDef *)I2C1_BASE), ENABLE);
    346          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_MODE_SELECT))
    347          		;
    348          	I2C_Send7bitAddress(((I2C_TypeDef *)I2C1_BASE), 0x74, I2C_Direction_Transmitter);
    349          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
    350          		;
    351          	I2C_SendData(((I2C_TypeDef *)I2C1_BASE), 0x07);
    352          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_BYTE_TRANSMITTED))
    353          		;
    354          	I2C_GenerateSTOP(((I2C_TypeDef *)I2C1_BASE), ENABLE);
    355          	I2C_GenerateSTART(((I2C_TypeDef *)I2C1_BASE), ENABLE);
    356          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_MODE_SELECT))
    357          		;
    358          	I2C_Send7bitAddress(((I2C_TypeDef *)I2C1_BASE), 0x75, I2C_Direction_Receiver);
    359          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
    360          		;
    361          	int low = I2C_ReceiveData(((I2C_TypeDef *)I2C1_BASE));
    362          	if (I2C_GetLastEvent((I2C_TypeDef *)I2C1_BASE) & 0x40 != 0x40)
    363          	{
    364          		int high = I2C_ReceiveData(((I2C_TypeDef *)I2C1_BASE));
    365          		if (high & 0x80 != 0)
    366          		{
    367          			return 20;
    368          		}
    369          		else
    370          		{
    371          			return (high << 8 + low) * 0.02 - 273.15;
    372          		}
    373          	}
    374          
    375          	I2C_AcknowledgeConfig(((I2C_TypeDef *)I2C1_BASE), ENABLE);
    376          }
    377          
    378          /*
    379           *********************************************************************************************************
    380           *                                            passTask()
    381           *
    382           * Description : Those who are at normal body temperature are allowed to pass.
    383           *
    384           * Argument(s) : p
    385           *
    386           * Return(s)   : none.
    387           *
    388           * Caller(s)   : This is a task.
    389           *
    390           * Note(s)     : none.
    391           *********************************************************************************************************
    392           */
    393          // 정상체온인 사람은 통과를 허가하는 Task
    394          static void passTask(void *p)
    395          {
    396          	int err;
    397          	while (DEF_TRUE)
    398          	{
    399          		OSFlagPend(flagGroup, (OS_FLAGS)(FLAG_DETECT + FLAG_TEMPER_NORMAL), OS_FLAG_WAIT_SET_ALL + OS_FLAG_CONSUME, 100, (INT8U *)&err);
    400          		startNotice();
    401          		stopAlert();
    402          
    403          		/*
    404          		OSFlagPend(flagGroup, FLAG_DETECT, OS_FLAG_WAIT_SET_ALL + OS_FLAG_CONSUME, 0, (INT8U *)&err);
    405          		int temp = (int)OSQPend(tempQue, 0, (INT8U *)&err);
    406          		if (temp > 40)
    407          		{
    408          			startAlert();
    409          		}
    410          		else if (temp > 30 && temp <= 40)
    411          		{
    412          			startNotice();
    413          		}
    414          		*/
    415          		//OSSemPend(sem, 0, (INT8U *)&err);
    416          		if (count == 0)
    417          			count = 1;
    418          		//OSSemPost(sem);
    419          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
    420          	}
    421          }
    422          
    423          /*
    424           *********************************************************************************************************
    425           *                                            denyTask()
    426           *
    427           * Description : People with abnormal body temperature are not allowed to pass through.
    428           *
    429           * Argument(s) : p
    430           *
    431           * Return(s)   : none.
    432           *
    433           * Caller(s)   : This is a task.
    434           *
    435           * Note(s)     : none.
    436           *********************************************************************************************************
    437           */
    438          // 비정상체온인 사람은 통과를 불허하는 Task
    439          static void denyTask(void *p)
    440          {
    441          	int err;
    442          	while (DEF_TRUE)
    443          	{
    444          		OSFlagPend(flagGroup,
    445          				   (OS_FLAGS)(FLAG_TEMPER_HIGH + FLAG_DETECT),
    446          				   OS_FLAG_WAIT_SET_ALL + OS_FLAG_CONSUME,
    447          				   100,
    448          				   (INT8U *)&err);
    449          		startAlert();
    450          		stopNotice();
    451          		//OSSemPend(sem, 0, (INT8U *)&err);
    452          		if (count == 0)
    453          			count = 1;
    454          		//OSSemPost(sem);
    455          
    456          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
    457          	}
    458          }
    459          
    460          /*
    461           *********************************************************************************************************
    462           *                                            checkTask()
    463           *
    464           * Description : Check dot-matrix, piezo, motor.
    465           *
    466           * Argument(s) : p
    467           *
    468           * Return(s)   : none.
    469           *
    470           * Caller(s)   : This is a task.
    471           *
    472           * Note(s)     : none.
    473           *********************************************************************************************************
    474           */
    475          // 경고를 일정 시간 후 정지하도록 하는 Task
    476          static void checkTask(void *p)
    477          {
    478          	CPU_INT08U err;
    479          	stopAlert();
    480          	stopNotice();
    481          	while (DEF_TRUE)
    482          	{
    483          		/*
    484          		if (count != 0)
    485          		{
    486          			check++;
    487          			if (check > 10)
    488          			{
    489          				stopAlert();
    490          				stopNotice();
    491          				//OSSemPend(sem, 0, &err);
    492          				count = 0;
    493          				//OSSemPost(sem);
    494          				check = 0;
    495          			}
    496          		}*/
    497          
    498          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
    499          	}
    500          }
    501          
    502          // Stop all
    503          static void stopAlert()
    504          {
    505          	// LED
    506          	GPIO_ResetBits(GPIOC, GPIO_Pin_12);
    507          	// piezo
    508          	GPIO_ResetBits(GPIOB, GPIO_Pin_8);
    509          }
    510          
    511          static void startAlert()
    512          {
    513          	stopNotice();
    514          	// LED
    515          	GPIO_SetBits(GPIOC, GPIO_Pin_12);
    516          	// piezo
    517          	GPIO_SetBits(GPIOB, GPIO_Pin_8);
    518          }
    519          
    520          static void stopNotice()
    521          {
    522          	GPIO_ResetBits(GPIOC, GPIO_Pin_11);
    523          }
    524          
    525          static void startNotice()
    526          {
    527          	stopAlert();
    528          	GPIO_SetBits(GPIOC, GPIO_Pin_11);
    529          }
    530          /*
    531           *********************************************************************************************************
    532           *                                            displayTask()
    533           *
    534           * Description : display with dot-matrix.
    535           *
    536           * Argument(s) : p
    537           *
    538           * Return(s)   : none.
    539           *
    540           * Caller(s)   : This is a task.
    541           *
    542           * Note(s)     : none.
    543           *********************************************************************************************************
    544           */
    545          /*
    546          // dot-matrix 출력
    547          static void
    548          displayTask(void *p)
    549          {
    550          	CPU_INT08U err;
    551          	int color = 0; // green
    552          	int shape = 0; // O
    553          	while (DEF_TRUE)
    554          	{
    555          		GPIO_SetBits(GPIOC, GPIO_Pin_6);
    556          		GPIO_SetBits(GPIOC, GPIO_Pin_8);
    557          		
    558          		for (int i = 0; i < 8; i++)
    559          		{
    560          			GPIO_SetBits(lineTypes[i], linePins[i]);
    561          			for (int j = 0; j < 8; j++)
    562          			{
    563          				GPIO_SetBits(orangeTypes[i], orangePins[j]);
    564          				
    565          				if (shape == 0 && shapeO[i][j] == 1)
    566          				{
    567          
    568          					GPIO_SetBits(orangeTypes[j], orangePins[j]);
    569          				}
    570          				else if (shape == 1 && shapeX[i][j] == 1)
    571          				{
    572          
    573          					GPIO_SetBits(orangeTypes[j], orangePins[j]);
    574          				}
    575          				else
    576          				{
    577          					//GPIO_ResetBits(orangeTypes[j], orangePins[j]);
    578          					//GPIO_ResetBits(greenTypes[j], greenPins[j]);
    579          				}
    580          				
    581          			}
    582          
    583          			GPIO_ResetBits(lineTypes[i], linePins[i]);
    584          		}
    585          		
    586          		OSTimeDlyHMSM(0, 0, 0, 30); // To run other tasks
    587          	}
    588          }
    589          */
    590          
    591          /*
    592           *********************************************************************************************************
    593           *                                            startTask()
    594           *
    595           * Description : Init task.
    596           *
    597           * Argument(s) : p
    598           *
    599           * Return(s)   : none.
    600           *
    601           * Caller(s)   : This is a task.
    602           *
    603           * Note(s)     : none.
    604           *********************************************************************************************************
    605           */
    606          // 경고를 일정 시간 후 정지하도록 하는 Task
    607          static void startTask(void *p)
    608          {
    609          	CPU_INT08U err;
    610          
    611          	OS_CPU_SysTickInit();
    612          
    613          	// Create Event Flag
    614          	flagGroup = OSFlagCreate(0, &err);
    615          
    616          	// Create msg que
    617          	//tempQue = OSQCreate(&tempBuffer[0], 10);
    618          
    619          	// Create semaphore
    620          	//sem = OSSemCreate(0);
    621          
    622          	stopAlert();
    623          	stopNotice();
    624          #if (OS_TASK_STAT_EN > 0)
    625          	OSStatInit(); /* Determine CPU capacity.                              */
    626          #endif
    627          
    628          #if ((APP_PROBE_COM_EN == DEF_ENABLED) || \
    629          	 (APP_OS_PROBE_EN == DEF_ENABLED))
    630          	App_InitProbe();
    631          #endif
    632          
    633          	while (DEF_TRUE)
    634          	{
    635          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
    636          	}
    637          }
    638          
    639          /*
    640           *********************************************************************************************************
    641           *                                          App_DispScr_SignOn()
    642           *
    643           * Description : Display uC/OS-II system information on the LCD.
    644           *
    645           * Argument(s) : none.
    646           *
    647           * Return(s)   : none.
    648           *
    649           * Caller(s)   : TaskUserIF().
    650           *
    651           * Note(s)     : none.
    652           *********************************************************************************************************
    653           */
    654          
    655          static void App_DispScr_SignOn(void)
    656          {
    657          }
    658          
    659          /*
    660           *********************************************************************************************************
    661           *                                          App_DispScr_SignOn()
    662           *
    663           * Description : Display uC/OS-II system information on the LCD.
    664           *
    665           * Argument(s) : none.
    666           *
    667           * Return(s)   : none.
    668           *
    669           * Caller(s)   : TaskUserIF().
    670           *
    671           * Note(s)     : none.
    672           *********************************************************************************************************
    673           */
    674          
    675          static void App_DispScr_TaskNames(void)
    676          {
    677          }
    678          
    679          /*
    680           *********************************************************************************************************
    681           *                                             App_InitProbe()
    682           *
    683           * Description : Initialize uC/Probe target code.
    684           *
    685           * Argument(s) : none.
    686           *
    687           * Return(s)   : none.
    688           *
    689           * Caller(s)   : App_TaskStart().
    690           *
    691           * Note(s)     : none.
    692           *********************************************************************************************************
    693           */
    694          
    695          #if ((APP_PROBE_COM_EN == DEF_ENABLED) || \
    696          	 (APP_OS_PROBE_EN == DEF_ENABLED))
    697          static void App_InitProbe(void)
    698          {
    699          #if (APP_OS_PROBE_EN == DEF_ENABLED)
    700          	(void)App_ProbeCounts;
    701          	(void)App_ProbeB1;
    702          
    703          #if ((APP_PROBE_COM_EN == DEF_ENABLED) && \
    704          	 (PROBE_COM_STAT_EN == DEF_ENABLED))
    705          	(void)App_ProbeComRxPktSpd;
    706          	(void)App_ProbeComTxPktSpd;
    707          	(void)App_ProbeComTxSymSpd;
    708          	(void)App_ProbeComTxSymByteSpd;
    709          #endif
    710          
    711          	OSProbe_Init();
    712          	OSProbe_SetCallback(App_ProbeCallback);
    713          	OSProbe_SetDelay(250);
    714          #endif
    715          
    716          #if (APP_PROBE_COM_EN == DEF_ENABLED)
    717          	ProbeCom_Init(); /* Initialize the uC/Probe communications module.       */
    718          #endif
    719          }
    720          #endif
    721          
    722          /*
    723           *********************************************************************************************************
    724           *                                         AppProbeCallback()
    725           *
    726           * Description : uC/Probe OS plugin callback.
    727           *
    728           * Argument(s) : none.
    729           *
    730           * Return(s)   : none.
    731           *
    732           * Caller(s)   : uC/Probe OS plugin task.
    733           *
    734           * Note(s)     : none.
    735           *********************************************************************************************************
    736           */
    737          
    738          #if (APP_OS_PROBE_EN == DEF_ENABLED)
    739          static void App_ProbeCallback(void)
    740          {
    741          #if ((APP_PROBE_COM_EN == DEF_ENABLED) && \
    742          	 (PROBE_COM_STAT_EN == DEF_ENABLED))
    743          	CPU_INT32U ctr_curr;
    744          	CPU_INT32U rxpkt_curr;
    745          	CPU_INT32U txpkt_curr;
    746          	CPU_INT32U sym_curr;
    747          	CPU_INT32U symbyte_curr;
    748          #endif
    749          
    750          	App_ProbeCounts++;
    751          
    752          	App_ProbeB1 = BSP_PB_GetStatus(1);
    753          
    754          #if ((APP_PROBE_COM_EN == DEF_ENABLED) && \
    755          	 (PROBE_COM_STAT_EN == DEF_ENABLED))
    756          	ctr_curr = OSTime;
    757          	rxpkt_curr = ProbeCom_RxPktCtr;
    758          	txpkt_curr = ProbeCom_TxPktCtr;
    759          	sym_curr = ProbeCom_TxSymCtr;
    760          	symbyte_curr = ProbeCom_TxSymByteCtr;
    761          
    762          	if ((ctr_curr - App_ProbeComCtrLast) >= OS_TICKS_PER_SEC)
    763          	{
    764          		App_ProbeComRxPktSpd = ((CPU_FP32)(rxpkt_curr - App_ProbeComRxPktLast) / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    765          		App_ProbeComTxPktSpd = ((CPU_FP32)(txpkt_curr - App_ProbeComTxPktLast) / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    766          		App_ProbeComTxSymSpd = ((CPU_FP32)(sym_curr - App_ProbeComTxSymLast) / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    767          		App_ProbeComTxSymByteSpd = ((CPU_FP32)(symbyte_curr - App_ProbeComTxSymByteLast) / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    768          
    769          		App_ProbeComCtrLast = ctr_curr;
    770          		App_ProbeComRxPktLast = rxpkt_curr;
    771          		App_ProbeComTxPktLast = txpkt_curr;
    772          		App_ProbeComTxSymLast = sym_curr;
    773          		App_ProbeComTxSymByteLast = symbyte_curr;
    774          	}
    775          #endif
    776          }
    777          #endif
    778          
    779          /*
    780           *********************************************************************************************************
    781           *                                      App_FormatDec()
    782           *
    783           * Description : Convert a decimal value to ASCII (without leading zeros).
    784           *
    785           * Argument(s) : pstr            Pointer to the destination ASCII string.
    786           *
    787           *               value           Value to convert (assumes an unsigned value).
    788           *
    789           *               digits          The desired number of digits.
    790           *
    791           * Return(s)   : none.
    792           *
    793           * Caller(s)   : various.
    794           *
    795           * Note(s)     : none.
    796           *********************************************************************************************************
    797           */
    798          
    799          /*
    800           *********************************************************************************************************
    801           *********************************************************************************************************
    802           *                                          uC/OS-II APP HOOKS
    803           *********************************************************************************************************
    804           *********************************************************************************************************
    805           */
    806          
    807          #if (OS_APP_HOOKS_EN > 0)
    808          /*
    809           *********************************************************************************************************
    810           *                                      TASK CREATION HOOK (APPLICATION)
    811           *
    812           * Description : This function is cal when a task is created.
    813           *
    814           * Argument(s) : ptcb   is a pointer to the task control block of the task being created.
    815           *
    816           * Note(s)     : (1) Interrupts are disabled during this call.
    817           *********************************************************************************************************
    818           */
    819          
    820          void App_TaskCreateHook(OS_TCB *ptcb)
    821          {
    822          #if ((APP_OS_PROBE_EN == DEF_ENABLED) && \
    823          	 (OS_PROBE_HOOKS_EN == DEF_ENABLED))
    824          	OSProbe_TaskCreateHook(ptcb);
    825          #endif
    826          }
    827          
    828          /*
    829           *********************************************************************************************************
    830           *                                    TASK DELETION HOOK (APPLICATION)
    831           *
    832           * Description : This function is called when a task is deleted.
    833           *
    834           * Argument(s) : ptcb   is a pointer to the task control block of the task being deleted.
    835           *
    836           * Note(s)     : (1) Interrupts are disabled during this call.
    837           *********************************************************************************************************
    838           */
    839          
    840          void App_TaskDelHook(OS_TCB *ptcb)
    841          {
    842          	(void)ptcb;
    843          }
    844          
    845          /*
    846           *********************************************************************************************************
    847           *                                      IDLE TASK HOOK (APPLICATION)
    848           *
    849           * Description : This function is called by OSTaskIdleHook(), which is called by the idle task.  This hook
    850           *               has been added to allow you to do such things as STOP the CPU to conserve power.
    851           *
    852           * Argument(s) : none.
    853           *
    854           * Note(s)     : (1) Interrupts are enabled during this call.
    855           *********************************************************************************************************
    856           */
    857          
    858          #if OS_VERSION >= 251
    859          void App_TaskIdleHook(void)
    860          {
    861          }
    862          #endif
    863          
    864          /*
    865           *********************************************************************************************************
    866           *                                        STATISTIC TASK HOOK (APPLICATION)
    867           *
    868           * Description : This function is called by OSTaskStatHook(), which is called every second by uC/OS-II's
    869           *               statistics task.  This allows your application to add functionality to the statistics task.
    870           *
    871           * Argument(s) : none.
    872           *********************************************************************************************************
    873           */
    874          
    875          void App_TaskStatHook(void)
    876          {
    877          }
    878          
    879          /*
    880           *********************************************************************************************************
    881           *                                        TASK SWITCH HOOK (APPLICATION)
    882           *
    883           * Description : This function is called when a task switch is performed.  This allows you to perform other
    884           *               operations during a context switch.
    885           *
    886           * Argument(s) : none.
    887           *
    888           * Note(s)     : (1) Interrupts are disabled during this call.
    889           *
    890           *               (2) It is assumed that the global pointer 'OSTCBHighRdy' points to the TCB of the task that
    891           *                   will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
    892           *                  task being switched out (i.e. the preempted task).
    893           *********************************************************************************************************
    894           */
    895          
    896          #if OS_TASK_SW_HOOK_EN > 0
    897          void App_TaskSwHook(void)
    898          {
    899          #if ((APP_OS_PROBE_EN == DEF_ENABLED) && \
    900          	 (OS_PROBE_HOOKS_EN == DEF_ENABLED))
    901          	OSProbe_TaskSwHook();
    902          #endif
    903          }
    904          #endif
    905          
    906          /*
    907           *********************************************************************************************************
    908           *                                     OS_TCBInit() HOOK (APPLICATION)
    909           *
    910           * Description : This function is called by OSTCBInitHook(), which is called by OS_TCBInit() after setting
    911           *               up most of the TCB.
    912           *
    913           * Argument(s) : ptcb    is a pointer to the TCB of the task being created.
    914           *
    915           * Note(s)     : (1) Interrupts may or may not be ENABLED during this call.
    916           *********************************************************************************************************
    917           */
    918          
    919          #if OS_VERSION >= 204
    920          void App_TCBInitHook(OS_TCB *ptcb)
    921          {
    922          	(void)ptcb;
    923          }
    924          #endif
    925          
    926          /*
    927           *********************************************************************************************************
    928           *                                        TICK HOOK (APPLICATION)
    929           *
    930           * Description : This function is called every tick.
    931           *
    932           * Argument(s) : none.
    933           *
    934           * Note(s)     : (1) Interrupts may or may not be ENABLED during this call.
    935           *********************************************************************************************************
    936           */
    937          
    938          #if OS_TIME_TICK_HOOK_EN > 0
    939          void App_TimeTickHook(void)
    940          {
    941          #if ((APP_OS_PROBE_EN == DEF_ENABLED) && \
    942          	 (OS_PROBE_HOOKS_EN == DEF_ENABLED))
    943          	OSProbe_TickHook();
    944          #endif
    945          }
    946          #endif
    947          #endif
    948          
    949          static void initAll()
    950          {
    951          	ADC_InitTypeDef adc_init;
    952          	GPIO_InitTypeDef gpio_init;
    953          	I2C_InitTypeDef i2c_init;
    954          	SPI_InitTypeDef spi_init;
    955          
    956          	// CLOCK
    957          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
    958          	//RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
    959          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
    960          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    961          	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    962          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    963          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
    964          
    965          	// PIN
    966          	// ADC - 인체 감지
    967          	gpio_init.GPIO_Pin = GPIO_Pin_1;
    968          	gpio_init.GPIO_Mode = GPIO_Mode_AIN;
    969          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    970          	GPIO_Init(GPIOB, &gpio_init);
    971          	//
    972          	// I2C - 온도 센서
    973          	gpio_init.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
    974          	gpio_init.GPIO_Mode = GPIO_Mode_AF_OD;
    975          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    976          	GPIO_Init(GPIOB, &gpio_init);
    977          	// 부저
    978          	gpio_init.GPIO_Pin = GPIO_Pin_8;
    979          	gpio_init.GPIO_Mode = GPIO_Mode_Out_PP;
    980          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    981          	GPIO_Init(GPIOB, &gpio_init);
    982          	/*
    983          	// SPI
    984          	gpio_init.GPIO_Pin = GPIO_Pin_12;
    985          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    986          	gpio_init.GPIO_Mode = GPIO_Mode_Out_PP;
    987          	GPIO_Init(GPIOB, &gpio_init);
    988          	gpio_init.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
    989          	gpio_init.GPIO_Mode = GPIO_Mode_AF_PP;
    990          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    991          	GPIO_Init(GPIOB, &gpio_init);
    992          	*/
    993          	// touch
    994          	gpio_init.GPIO_Pin = GPIO_Pin_7;
    995          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    996          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    997          	GPIO_Init(GPIOC, &gpio_init);
    998          
    999          	// LED
   1000          	gpio_init.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
   1001          	gpio_init.GPIO_Mode = GPIO_Mode_Out_PP;
   1002          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   1003          	GPIO_Init(GPIOC, &gpio_init);
   1004          
   1005          	/*
   1006          	// analog - dot-matrix
   1007          	gpio_init.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
   1008          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   1009          	gpio_init.GPIO_Mode = GPIO_Mode_Out_PP;
   1010          	GPIO_Init(GPIOA, &gpio_init);
   1011          
   1012          	gpio_init.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_0;
   1013          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   1014          	gpio_init.GPIO_Mode = GPIO_Mode_Out_PP;
   1015          	GPIO_Init(GPIOB, &gpio_init);
   1016          
   1017          	gpio_init.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9;
   1018          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
   1019          	gpio_init.GPIO_Mode = GPIO_Mode_Out_PP;
   1020          	GPIO_Init(GPIOC, &gpio_init);
   1021          */
   1022          	/*
   1023          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
   1024            	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   1025            	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
   1026            	GPIO_Init(GPIOD, &GPIO_InitStructure);
   1027          */
   1028          	// CONFIG
   1029          	// ADC
   1030          	adc_init.ADC_Mode = ADC_Mode_Independent;
   1031          	adc_init.ADC_ScanConvMode = ENABLE;
   1032          	adc_init.ADC_ContinuousConvMode = ENABLE;
   1033          	adc_init.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
   1034          	adc_init.ADC_DataAlign = ADC_DataAlign_Right;
   1035          	adc_init.ADC_NbrOfChannel = 1;
   1036          	ADC_Init(ADC1, &adc_init);
   1037          	ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 1, ADC_SampleTime_41Cycles5);
   1038          	ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE);
   1039          	ADC_Cmd(ADC1, ENABLE);
   1040          
   1041          	ADC_ResetCalibration(ADC1);
   1042          	while (ADC_GetResetCalibrationStatus(ADC1) != RESET)
   1043          		;
   1044          	ADC_StartCalibration(ADC1);
   1045          	while (ADC_GetCalibrationStatus(ADC1) != RESET)
   1046          		;
   1047          	ADC_SoftwareStartConvCmd(ADC1, ENABLE);
   1048          
   1049          	// I2C
   1050          	i2c_init.I2C_Mode = I2C_Mode_I2C;
   1051          	i2c_init.I2C_DutyCycle = I2C_DutyCycle_2;
   1052          	i2c_init.I2C_OwnAddress1 = 0;
   1053          	i2c_init.I2C_Ack = I2C_Ack_Enable;
   1054          	i2c_init.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   1055          	i2c_init.I2C_ClockSpeed = 100000;
   1056          	I2C_Init(((I2C_TypeDef *)I2C1_BASE), &i2c_init);
   1057          	I2C_Cmd(((I2C_TypeDef *)I2C1_BASE), ENABLE);
   1058          	/*
   1059          	// SPI
   1060          	spi_init.SPI_Direction = SPI_Direction_1Line_Tx;
   1061          	spi_init.SPI_Mode = SPI_Mode_Master;
   1062          	spi_init.SPI_DataSize = SPI_DataSize_16b;
   1063          	spi_init.SPI_CPOL = SPI_CPOL_Low;
   1064          	spi_init.SPI_CPHA = SPI_CPHA_1Edge;
   1065          	spi_init.SPI_NSS = SPI_NSS_Soft;
   1066          	spi_init.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
   1067          	spi_init.SPI_FirstBit = SPI_FirstBit_MSB;
   1068          	spi_init.SPI_CRCPolynomial;
   1069          	SPI_Init(SPI2, &spi_init);
   1070          	SPI_Cmd(SPI2, ENABLE);
   1071          	*/
   1072          }

Errors: 1
Warnings: 13
