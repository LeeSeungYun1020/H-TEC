###############################################################################
#
# IAR ANSI C/C++ Compiler V8.50.9.278/W32 for ARM         23/Dec/2020  16:16:38
# Copyright 1999-2020 IAR Systems AB.
#
#    Cpu mode                        
#    Endian                       =  little
#    Source file                  =
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\app.c
#    Command line                 =
#        -f C:\Users\fabi8\AppData\Local\Temp\EWADF8.tmp
#        (D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\app.c
#        -lCN
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List
#        -o
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "D:\Develop\IAR Systems\arm\inc\c\DLib_Config_Normal.h" -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\ports\arm-cortex-m3\generic\iar\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\ucos-ii\source\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-lib\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uc-cpu\ARM-Cortex-M3\IAR\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\cpu\st\stm32\inc\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\BSP\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Source\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\RS-232\Ports\ST\STM32\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Communication\Generic\Source\\
#        -I
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II\\
#        -Ohz --use_c++_inline)
#    Locale                       =  C
#    List file                    =
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\List\app.lst
#    Object file                  =
#        D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\Flash\Obj\app.o
#    Runtime model:                  
#      __SystemLibrary            =  DLib
#      __dlib_file_descriptor     =  0
#      __dlib_full_locale_support =  0
#      __dlib_version             =  6
#      __size_limit               =  32768|ARM.EW.LINKER
#
###############################################################################

D:\Develop\H-TEC\Micrium\Software\EvalBoards\ST\STM3210B-EVAL\IAR\OS-Probe\app.c
      1          /*
      2           *********************************************************************************************************
      3           *                                              TERM PROJECT
      4           *                          (C) Copyright 2020; Lee Seung Yun; Shim Jae Yeong
      5           *               Some codes are referenced below.
      6           *
      7           *                                              EXAMPLE CODE
      8           *
      9           *                          (c) Copyright 2003-2006; Micrium, Inc.; Weston, FL
     10           *
     11           *               All rights reserved.  Protected by international copyright laws.
     12           *               Knowledge of the source code may NOT be used to develop a similar product.
     13           *               Please help us continue to provide the Embedded community with the finest
     14           *               software available.  Your honesty is greatly appreciated.
     15           *********************************************************************************************************
     16           */
     17          
     18          /*
     19          *********************************************************************************************************
     20          *
     21          *                             High Temperature Entrance Checking Technique
     22          *
     23          *                                     ST Microelectronics STM32
     24          *                                              with the
     25          *                                   STM3210B-EVAL Evaluation Board
     26          *
     27          * Filename      : app.c
     28          * Version       : V1.0
     29          * Programmer(s) : Lee Seung Yun, Shim Jae Yeong
     30          *********************************************************************************************************
     31          */
     32          
     33          /*
     34          *********************************************************************************************************
     35          *                                             INCLUDE FILES
     36          *********************************************************************************************************
     37          */
     38          
     39          #include <includes.h>
     40          
     41          /*
     42          *********************************************************************************************************
     43          *                                            LOCAL DEFINES
     44          *********************************************************************************************************
     45          */
     46          
     47          // USE TOUCH SENSOR
     48          #define MANUAL
     49          // USE HUMAN DETEDCT SENSOR
     50          // #define AUTO
     51          
     52          /*
     53          *********************************************************************************************************
     54          *                                       LOCAL GLOBAL VARIABLES
     55          *********************************************************************************************************
     56          */
     57          
     58          // Task Stack (size: 128)

   \                                 In section .bss, align 4
     59          static OS_STK detectTaskStack[TASK_STK_SIZE];
   \                     detectTaskStack:
   \        0x0                      DS8 512
   \      0x200                      DS8 512
   \      0x400                      DS8 512
   \      0x600                      DS8 512
   \      0x800                      DS8 512
   \      0xA00                      DS8 512
     60          static OS_STK temperatureTaskStack[TASK_STK_SIZE];
     61          static OS_STK passTaskStack[TASK_STK_SIZE];
     62          static OS_STK denyTaskStack[TASK_STK_SIZE];
     63          static OS_STK checkTaskStack[TASK_STK_SIZE];
     64          static OS_STK startTaskStack[TASK_STK_SIZE];
     65          
     66          // Event Flags

   \                                 In section .bss, align 4
     67          static OS_FLAG_GRP *flagGroup;
   \                     flagGroup:
   \        0x0                      DS8 4
   \        0x4                      DS8 4
   \        0x8                      DS8 4
   \        0xC                      DS8 4
   \       0x10                      DS8 4
     68          const static int FLAG_INIT = 0;
     69          const static int FLAG_DETECT = 1;
     70          const static int FLAG_DETECT_NOT = 2;
     71          const static int FLAG_TEMPER_NORMAL = 4;
     72          const static int FLAG_TEMPER_HIGH = 8;
     73          const static int FLAG_TEMPER_LOW = 16;
     74          
     75          // time
     76          static OS_EVENT *sem;
     77          static int count = 0;
     78          static int check = 0;
     79          static int read = 0;
     80          const static int DELAY_TIME = 1000;
     81          
     82          #if ((APP_OS_PROBE_EN == DEF_ENABLED) &&  \
     83          	 (APP_PROBE_COM_EN == DEF_ENABLED) && \
     84          	 (PROBE_COM_STAT_EN == DEF_ENABLED))

   \                                 In section .bss, align 4
   \        0x0                      DS8 4
     85          static CPU_FP32 App_ProbeComRxPktSpd;

   \                                 In section .bss, align 4
   \        0x0                      DS8 4
     86          static CPU_FP32 App_ProbeComTxPktSpd;

   \                                 In section .bss, align 4
   \        0x0                      DS8 4
     87          static CPU_FP32 App_ProbeComTxSymSpd;

   \                                 In section .bss, align 4
   \        0x0                      DS8 4
     88          static CPU_FP32 App_ProbeComTxSymByteSpd;
     89          

   \                                 In section .bss, align 4
     90          static CPU_INT32U App_ProbeComRxPktLast;
   \                     App_ProbeComRxPktLast:
   \        0x0                      DS8 4
   \        0x4                      DS8 4
   \        0x8                      DS8 4
   \        0xC                      DS8 4
   \       0x10                      DS8 4
   \       0x14                      DS8 4
     91          static CPU_INT32U App_ProbeComTxPktLast;
     92          static CPU_INT32U App_ProbeComTxSymLast;
     93          static CPU_INT32U App_ProbeComTxSymByteLast;
     94          
     95          static CPU_INT32U App_ProbeComCtrLast;
     96          #endif
     97          
     98          #if (APP_OS_PROBE_EN == DEF_ENABLED)
     99          static CPU_INT32U App_ProbeCounts;

   \                                 In section .bss, align 1
   \        0x0                      DS8 1
    100          static CPU_BOOLEAN App_ProbeB1;
    101          
    102          #endif
    103          
    104          /*
    105           *********************************************************************************************************
    106           *                                      LOCAL FUNCTION PROTOTYPES
    107           *********************************************************************************************************
    108           */
    109          
    110          // Task function
    111          static void detectTask(void *p);
    112          static void temperTask(void *p);
    113          static void passTask(void *p);
    114          static void denyTask(void *p);
    115          static void checkTask(void *p);
    116          static void startTask(void *p);
    117          
    118          static void App_DispScr_SignOn(void);
    119          static void DispScr_TaskNames(void);
    120          
    121          static int readTemperature(void);
    122          static void stopAlert();
    123          static void startAlert();
    124          static void stopNotice();
    125          static void startNotice();
    126          static void initAll();
    127          
    128          #if ((APP_PROBE_COM_EN == DEF_ENABLED) || \
    129          	 (APP_OS_PROBE_EN == DEF_ENABLED))
    130          static void App_InitProbe(void);
    131          #endif
    132          
    133          #if (APP_OS_PROBE_EN == DEF_ENABLED)
    134          static void App_ProbeCallback(void);
    135          #endif
    136          
    137          /*
    138           *********************************************************************************************************
    139           *                                                main()
    140           *
    141           * Description : This is the standard entry point for C code.  It is assumed that your code will call
    142           *               main() once you have performed all necessary initialization.
    143           *
    144           * Argument(s) : none.
    145           *
    146           * Return(s)   : none.
    147           *********************************************************************************************************
    148           */
    149          

   \                                 In section .text, align 2, keep-with-next
    150          int main(void)
    151          {
   \                     main: (+1)
   \        0x0   0xB530             PUSH     {R4,R5,LR}
   \        0x2   0xB08B             SUB      SP,SP,#+44
    152          	CPU_INT08U os_err;
    153          
    154          	/* Disable all ints until we are ready to accept them.  */
    155          	BSP_IntDisAll();
   \        0x4   0x....'....        BL       BSP_IntDisAll
    156          
    157          	/* Initialize "uC/OS-II, The Real-Time Kernel".         */
    158          	OSInit();
   \        0x8   0x....'....        BL       OSInit
    159          
    160          	initAll();
   \        0xC   0x2101             MOVS     R1,#+1
   \        0xE   0xF44F 0x1000      MOV      R0,#+2097152
   \       0x12   0x....'....        BL       RCC_APB1PeriphClockCmd
   \       0x16   0x2101             MOVS     R1,#+1
   \       0x18   0x2001             MOVS     R0,#+1
   \       0x1A   0x....'....        BL       RCC_APB2PeriphClockCmd
   \       0x1E   0x2101             MOVS     R1,#+1
   \       0x20   0xF44F 0x7000      MOV      R0,#+512
   \       0x24   0x....'....        BL       RCC_APB2PeriphClockCmd
   \       0x28   0x2101             MOVS     R1,#+1
   \       0x2A   0x2008             MOVS     R0,#+8
   \       0x2C   0x....'....        BL       RCC_APB2PeriphClockCmd
   \       0x30   0x2101             MOVS     R1,#+1
   \       0x32   0x2010             MOVS     R0,#+16
   \       0x34   0x....'....        BL       RCC_APB2PeriphClockCmd
   \       0x38   0x20C0             MOVS     R0,#+192
   \       0x3A   0x211C             MOVS     R1,#+28
   \       0x3C   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_2: (+1)
   \       0x40   0x....'....        LDR.W    R4,??DataTable14  ;; 0x40010c00
   \       0x44   0x....'....        LDR.W    R5,??DataTable14_1  ;; 0x40011000
   \       0x48   0x4620             MOV      R0,R4
   \       0x4A   0x....'....        BL       GPIO_Init
   \       0x4E   0xF44F 0x7000      MOV      R0,#+512
   \       0x52   0x2104             MOVS     R1,#+4
   \       0x54   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_1: (+1)
   \       0x58   0xF44F 0x7080      MOV      R0,#+256
   \       0x5C   0x2110             MOVS     R1,#+16
   \       0x5E   0x....'....        BL       ?Subroutine2
   \                     ??CrossCallReturnLabel_3: (+1)
   \       0x62   0x4620             MOV      R0,R4
   \       0x64   0x....'....        BL       GPIO_Init
   \       0x68   0xF44F 0x50C0      MOV      R0,#+6144
   \       0x6C   0x2110             MOVS     R1,#+16
   \       0x6E   0x....'....        BL       ?Subroutine1
   \                     ??CrossCallReturnLabel_0: (+1)
   \       0x72   0x2201             MOVS     R2,#+1
   \       0x74   0xF88D 0x201C      STRB     R2,[SP, #+28]
   \       0x78   0xF88D 0x201D      STRB     R2,[SP, #+29]
   \       0x7C   0x2100             MOVS     R1,#+0
   \       0x7E   0xF44F 0x2260      MOV      R2,#+917504
   \       0x82   0x9208             STR      R2,[SP, #+32]
   \       0x84   0x9106             STR      R1,[SP, #+24]
   \       0x86   0x9109             STR      R1,[SP, #+36]
   \       0x88   0x2201             MOVS     R2,#+1
   \       0x8A   0xF88D 0x2028      STRB     R2,[SP, #+40]
   \       0x8E   0xA906             ADD      R1,SP,#+24
   \       0x90   0x....'....        LDR.W    R4,??DataTable14_2  ;; 0x40012400
   \       0x94   0x4620             MOV      R0,R4
   \       0x96   0x....'....        BL       ADC_Init
   \       0x9A   0x2304             MOVS     R3,#+4
   \       0x9C   0x2201             MOVS     R2,#+1
   \       0x9E   0x2108             MOVS     R1,#+8
   \       0xA0   0x4620             MOV      R0,R4
   \       0xA2   0x....'....        BL       ADC_RegularChannelConfig
   \       0xA6   0x2201             MOVS     R2,#+1
   \       0xA8   0xF44F 0x7108      MOV      R1,#+544
   \       0xAC   0x4620             MOV      R0,R4
   \       0xAE   0x....'....        BL       ADC_ITConfig
   \       0xB2   0x2101             MOVS     R1,#+1
   \       0xB4   0x4620             MOV      R0,R4
   \       0xB6   0x....'....        BL       ADC_Cmd
   \       0xBA   0x4620             MOV      R0,R4
   \       0xBC   0x....'....        BL       ADC_ResetCalibration
   \                     ??main_0: (+1)
   \       0xC0   0x4620             MOV      R0,R4
   \       0xC2   0x....'....        BL       ADC_GetResetCalibrationStatus
   \       0xC6   0x2800             CMP      R0,#+0
   \       0xC8   0xD1FA             BNE.N    ??main_0
   \       0xCA   0x4620             MOV      R0,R4
   \       0xCC   0x....'....        BL       ADC_StartCalibration
   \                     ??main_1: (+1)
   \       0xD0   0x4620             MOV      R0,R4
   \       0xD2   0x....'....        BL       ADC_GetCalibrationStatus
   \       0xD6   0x2800             CMP      R0,#+0
   \       0xD8   0xD1FA             BNE.N    ??main_1
   \       0xDA   0x2101             MOVS     R1,#+1
   \       0xDC   0x4620             MOV      R0,R4
   \       0xDE   0x....'....        BL       ADC_SoftwareStartConvCmd
   \       0xE2   0xF64B 0x72FF      MOVW     R2,#+49151
   \       0xE6   0xF8AD 0x2006      STRH     R2,[SP, #+6]
   \       0xEA   0x2100             MOVS     R1,#+0
   \       0xEC   0xF8AD 0x1004      STRH     R1,[SP, #+4]
   \       0xF0   0xF8AD 0x1008      STRH     R1,[SP, #+8]
   \       0xF4   0xF44F 0x6280      MOV      R2,#+1024
   \       0xF8   0xF8AD 0x200A      STRH     R2,[SP, #+10]
   \       0xFC   0xF44F 0x4180      MOV      R1,#+16384
   \      0x100   0xF8AD 0x100C      STRH     R1,[SP, #+12]
   \      0x104   0xA901             ADD      R1,SP,#+4
   \      0x106   0x....'....        LDR.W    R2,??DataTable14_3  ;; 0x186a0
   \      0x10A   0x....'....        LDR.W    R4,??DataTable14_4  ;; 0x40005400
   \      0x10E   0x9204             STR      R2,[SP, #+16]
   \      0x110   0x4620             MOV      R0,R4
   \      0x112   0x....'....        BL       I2C_Init
   \      0x116   0x2101             MOVS     R1,#+1
   \      0x118   0x4620             MOV      R0,R4
   \      0x11A   0x....'....        BL       I2C_Cmd
    161          
    162          	os_err = OSTaskCreateExt((void (*)(void *))detectTask,						   // Task가 수행할 함수, 사람의 존재 유/무를 알려주는 Task
    163          							 (void *)0,											   // Task로 넘겨줄 인자
    164          							 (OS_STK *)&detectTaskStack[TASK_STK_SIZE - 1],		   // Task가 할당될 Stack의 Top을 가리키는 주소
    165          							 (INT8U)TASK_DETECT_PRIO,							   // Task의 우선 순위 (MPT)
    166          							 (INT16U)TASK_DETECT_PRIO,							   // Task를 지칭하는 유일한 식별자, Task 갯수의 극복을 위해서 사용할 예정, 현재는 우선 순위와 같게끔 설정
    167          							 (OS_STK *)&detectTaskStack,						   // Task가 할당될 Stack의 마지막을 가리키는 주소, Stack 검사용으로 사용
    168          							 (INT32U)TASK_STK_SIZE,								   // Task Stack의 크기를 의미
    169          							 (void *)0,											   // Task Control Block 활용시 사용
    170          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK)); // Task 생성 옵션
   \      0x11E   0x2003             MOVS     R0,#+3
   \      0x120   0x2280             MOVS     R2,#+128
   \      0x122   0x9004             STR      R0,[SP, #+16]
   \      0x124   0x2100             MOVS     R1,#+0
   \      0x126   0x9202             STR      R2,[SP, #+8]
   \      0x128   0x2306             MOVS     R3,#+6
   \      0x12A   0x....'....        LDR.W    R4,??DataTable14_5
   \      0x12E   0x9103             STR      R1,[SP, #+12]
   \      0x130   0x9300             STR      R3,[SP, #+0]
   \      0x132   0x9401             STR      R4,[SP, #+4]
   \      0x134   0xF504 0x72FE      ADD      R2,R4,#+508
   \      0x138   0x....'....        ADR.W    R0,detectTask
   \      0x13C   0x....'....        BL       OSTaskCreateExt
   \      0x140   0x....'....        BL       ?Subroutine6
    171          
    172          	os_err = OSTaskCreateExt((void (*)(void *))temperTask, // 사람의 온도를 측정하여 통과할지 말지를 결정하는 Task
    173          							 (void *)0,
    174          							 (OS_STK *)&temperatureTaskStack[TASK_STK_SIZE - 1],
    175          							 (INT8U)TASK_TEMPER_PRIO,
    176          							 (INT16U)TASK_TEMPER_PRIO,
    177          							 (OS_STK *)&temperatureTaskStack,
    178          							 (INT32U)TASK_STK_SIZE,
    179          							 (void *)0,
    180          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
   \                     ??CrossCallReturnLabel_20: (+1)
   \      0x144   0xF504 0x7300      ADD      R3,R4,#+512
   \      0x148   0x2004             MOVS     R0,#+4
   \      0x14A   0x....'....        BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_9: (+1)
   \      0x14E   0x2304             MOVS     R3,#+4
   \      0x150   0xF504 0x727F      ADD      R2,R4,#+1020
   \      0x154   0x....'....        ADR.W    R0,temperTask
   \      0x158   0x....'....        BL       OSTaskCreateExt
   \      0x15C   0x....'....        BL       ?Subroutine6
    181          
    182          	os_err = OSTaskCreateExt((void (*)(void *))passTask, // 정상체온인 사람은 통과를 허가하는 Task
    183          							 (void *)0,
    184          							 (OS_STK *)&passTaskStack[TASK_STK_SIZE - 1],
    185          							 (INT8U)TASK_PASS_PRIO,
    186          							 (INT16U)TASK_PASS_PRIO,
    187          							 (OS_STK *)&passTaskStack,
    188          							 (INT32U)TASK_STK_SIZE,
    189          							 (void *)0,
    190          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
   \                     ??CrossCallReturnLabel_21: (+1)
   \      0x160   0xF504 0x6380      ADD      R3,R4,#+1024
   \      0x164   0x200B             MOVS     R0,#+11
   \      0x166   0x....'....        BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_10: (+1)
   \      0x16A   0x230B             MOVS     R3,#+11
   \      0x16C   0xF204 0x52FC      ADDW     R2,R4,#+1532
   \      0x170   0x....'....        ADR.W    R0,passTask
   \      0x174   0x....'....        BL       OSTaskCreateExt
   \      0x178   0x....'....        BL       ?Subroutine6
    191          
    192          	os_err = OSTaskCreateExt((void (*)(void *))denyTask, // 비정상체온인 사람은 통과를 불허하는 Task
    193          							 (void *)0,
    194          							 (OS_STK *)&denyTaskStack[TASK_STK_SIZE - 1],
    195          							 (INT8U)TASK_DENY_PRIO,
    196          							 (INT16U)TASK_DENY_PRIO,
    197          							 (OS_STK *)&denyTaskStack,
    198          							 (INT32U)TASK_STK_SIZE,
    199          							 (void *)0,
    200          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
   \                     ??CrossCallReturnLabel_22: (+1)
   \      0x17C   0xF504 0x63C0      ADD      R3,R4,#+1536
   \      0x180   0x200C             MOVS     R0,#+12
   \      0x182   0x....'....        BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_11: (+1)
   \      0x186   0x230C             MOVS     R3,#+12
   \      0x188   0xF204 0x72FC      ADDW     R2,R4,#+2044
   \      0x18C   0x....'....        ADR.W    R0,denyTask
   \      0x190   0x....'....        BL       OSTaskCreateExt
   \      0x194   0x....'....        BL       ?Subroutine6
    201          
    202          	os_err = OSTaskCreateExt((void (*)(void *))checkTask, // 알림 장치 작동 중지하는 Task
    203          							 (void *)0,
    204          							 (OS_STK *)&checkTaskStack[TASK_STK_SIZE - 1],
    205          							 (INT8U)TASK_CHECK_PRIO,
    206          							 (INT16U)TASK_CHECK_PRIO,
    207          							 (OS_STK *)&checkTaskStack,
    208          							 (INT32U)TASK_STK_SIZE,
    209          							 (void *)0,
    210          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
   \                     ??CrossCallReturnLabel_23: (+1)
   \      0x198   0xF504 0x6300      ADD      R3,R4,#+2048
   \      0x19C   0x2005             MOVS     R0,#+5
   \      0x19E   0x....'....        BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_12: (+1)
   \      0x1A2   0x2305             MOVS     R3,#+5
   \      0x1A4   0xF604 0x12FC      ADDW     R2,R4,#+2556
   \      0x1A8   0x....'....        ADR.W    R0,checkTask
   \      0x1AC   0x....'....        BL       OSTaskCreateExt
   \      0x1B0   0xF88D 0x0014      STRB     R0,[SP, #+20]
    211          
    212          	os_err = OSTaskCreateExt((void (*)(void *))startTask, // 초기화 Task
    213          							 (void *)0,
    214          							 (OS_STK *)&startTaskStack[TASK_STK_SIZE - 1],
    215          							 (INT8U)TASK_START_PRIO,
    216          							 (INT16U)TASK_START_PRIO,
    217          							 (OS_STK *)startTaskStack,
    218          							 (INT32U)TASK_STK_SIZE,
    219          							 (void *)0,
    220          							 (INT16U)(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));
   \      0x1B4   0x2280             MOVS     R2,#+128
   \      0x1B6   0x2003             MOVS     R0,#+3
   \      0x1B8   0xF504 0x6320      ADD      R3,R4,#+2560
   \      0x1BC   0x9004             STR      R0,[SP, #+16]
   \      0x1BE   0x....'....        BL       ?Subroutine4
   \                     ??CrossCallReturnLabel_13: (+1)
   \      0x1C2   0x2303             MOVS     R3,#+3
   \      0x1C4   0xF604 0x32FC      ADDW     R2,R4,#+3068
   \      0x1C8   0x....'....        ADR.W    R0,startTask
   \      0x1CC   0x....'....        BL       OSTaskCreateExt
   \      0x1D0   0xF88D 0x0014      STRB     R0,[SP, #+20]
    221          
    222          #if (OS_TASK_NAME_SIZE >= 11)
    223          	OSTaskNameSet(TASK_DETECT_PRIO, (CPU_INT08U *)"Detect Task", &os_err);
   \      0x1D4   0xAA05             ADD      R2,SP,#+20
   \      0x1D6   0x....'....        ADR.W    R1,?_0
   \      0x1DA   0x2006             MOVS     R0,#+6
   \      0x1DC   0x....'....        BL       OSTaskNameSet
    224          	OSTaskNameSet(TASK_TEMPER_PRIO, (CPU_INT08U *)"Temperature Task", &os_err);
   \      0x1E0   0xAA05             ADD      R2,SP,#+20
   \      0x1E2   0x....'....        ADR.W    R1,?_1
   \      0x1E6   0x2004             MOVS     R0,#+4
   \      0x1E8   0x....'....        BL       OSTaskNameSet
    225          	OSTaskNameSet(TASK_PASS_PRIO, (CPU_INT08U *)"Pass Task", &os_err);
   \      0x1EC   0xAA05             ADD      R2,SP,#+20
   \      0x1EE   0x....'....        ADR.W    R1,?_2
   \      0x1F2   0x200B             MOVS     R0,#+11
   \      0x1F4   0x....'....        BL       OSTaskNameSet
    226          	OSTaskNameSet(TASK_DENY_PRIO, (CPU_INT08U *)"Deny Task", &os_err);
   \      0x1F8   0xAA05             ADD      R2,SP,#+20
   \      0x1FA   0x....'....        ADR.W    R1,?_3
   \      0x1FE   0x200C             MOVS     R0,#+12
   \      0x200   0x....'....        BL       OSTaskNameSet
    227          	OSTaskNameSet(TASK_CHECK_PRIO, (CPU_INT08U *)"Check Task", &os_err);
   \      0x204   0xAA05             ADD      R2,SP,#+20
   \      0x206   0x....'....        ADR.W    R1,?_4
   \      0x20A   0x2005             MOVS     R0,#+5
   \      0x20C   0x....'....        BL       OSTaskNameSet
    228          	OSTaskNameSet(TASK_START_PRIO, (CPU_INT08U *)"Start Task", &os_err);
   \      0x210   0xAA05             ADD      R2,SP,#+20
   \      0x212   0x....'....        ADR.W    R1,?_5
   \      0x216   0x2003             MOVS     R0,#+3
   \      0x218   0x....'....        BL       OSTaskNameSet
    229          #endif
    230          
    231          	OSStart(); /* Start multitasking (i.e. give control to uC/OS-II).  */
   \      0x21C   0x....'....        BL       OSStart
    232          
    233          	return (0);
   \      0x220   0x2000             MOVS     R0,#+0
   \      0x222   0xB00B             ADD      SP,SP,#+44
   \      0x224   0xBD30             POP      {R4,R5,PC}       ;; return
    234          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine6: (+1)
   \        0x0   0xF88D 0x0014      STRB     R0,[SP, #+20]
   \        0x4   0x2280             MOVS     R2,#+128
   \        0x6   0x2003             MOVS     R0,#+3
   \        0x8   0x9004             STR      R0,[SP, #+16]
   \        0xA   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine4: (+1)
   \        0x0   0x2100             MOVS     R1,#+0
   \        0x2   0x9202             STR      R2,[SP, #+8]
   \        0x4   0x9301             STR      R3,[SP, #+4]
   \        0x6   0x9000             STR      R0,[SP, #+0]
   \        0x8   0x9103             STR      R1,[SP, #+12]
   \        0xA   0x4770             BX       LR
    235          
    236          /*
    237           *********************************************************************************************************
    238           *                                          detectTask()
    239           *
    240           * Description : Human detecting task. Monitor the existence of people,
    241           *
    242           * Argument(s) : p
    243           *
    244           * Return(s)   : none.
    245           *
    246           * Caller(s)   : This is a task.
    247           *
    248           * Note(s)     : none.
    249           *********************************************************************************************************
    250           */
    251          
    252          // 상황 감지 Task

   \                                 In section .text, align 4, keep-with-next
    253          static void detectTask(void *p)
    254          {
   \                     detectTask: (+1)
   \        0x0   0xB580             PUSH     {R7,LR}
    255          	CPU_INT08U err;
    256          
    257          	while (DEF_TRUE)
    258          	{
    259          		int val;
    260          #ifdef AUTO
    261          		val = GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1);
    262          #endif
    263          #ifdef MANUAL
    264          		val = GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_9);
    265          
    266          #endif
    267          		if (val != 0) // when human detected(auto) or touch button(manual)
   \                     ??detectTask_0: (+1)
   \        0x2   0xF44F 0x7100      MOV      R1,#+512
   \        0x6   0x....             LDR.N    R0,??DataTable14_1  ;; 0x40011000
   \        0x8   0x....'....        BL       GPIO_ReadInputDataBit
   \        0xC   0x2800             CMP      R0,#+0
    268          		{
    269          			OSFlagPost(flagGroup, (OS_FLAGS)FLAG_DETECT, OS_FLAG_SET, &err);
    270          		}
    271          		else
    272          		{
    273          			OSFlagPost(flagGroup, (OS_FLAGS)FLAG_DETECT_NOT, OS_FLAG_SET, &err);
   \        0xE   0x....             LDR.N    R0,??DataTable14_6
   \       0x10   0x6800             LDR      R0,[R0, #+0]
   \       0x12   0x466B             MOV      R3,SP
   \       0x14   0xBF07             ITTEE    EQ
   \       0x16   0x2201             MOVEQ    R2,#+1
   \       0x18   0x2102             MOVEQ    R1,#+2
   \       0x1A   0x2201             MOVNE    R2,#+1
   \       0x1C   0x2101             MOVNE    R1,#+1
   \       0x1E   0x....'....        BL       OSFlagPost
    274          		}
    275          
    276          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
   \       0x22   0x....'....        BL       ?Subroutine5
    277          	}
   \                     ??CrossCallReturnLabel_19: (+1)
   \       0x26   0xE7EC             B.N      ??detectTask_0
    278          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine5: (+1)
   \        0x0   0xF44F 0x737A      MOV      R3,#+1000
   \        0x4   0x2200             MOVS     R2,#+0
   \        0x6   0x2100             MOVS     R1,#+0
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x....'....        B.W      OSTimeDlyHMSM
    279          
    280          /*
    281           *********************************************************************************************************
    282           *                                            temperTask()
    283           *
    284           * Description : Measure a person's temperature
    285           *
    286           * Argument(s) : p
    287           *
    288           * Return(s)   : none.
    289           *
    290           * Caller(s)   : This is a task.
    291           *
    292           * Note(s)     : none.
    293           *********************************************************************************************************
    294           */
    295          
    296          // 사람의 온도를 측정하여 통과할지 말지를 결정하는 Task

   \                                 In section .text, align 4, keep-with-next
    297          static void temperTask(void *p)
    298          {
   \                     temperTask: (+1)
   \        0x0   0xB57C             PUSH     {R2-R6,LR}
    299          	INT8U err;
    300          	int temp;
    301          	int high = 40;
    302          	int low = 30;
   \        0x2   0x....             LDR.N    R4,??DataTable14_7  ;; 0x30001
   \        0x4   0x....             LDR.N    R5,??DataTable14_4  ;; 0x40005400
   \        0x6   0x....             LDR.N    R6,??DataTable14_6
   \        0x8   0xE04D             B.N      ??CrossCallReturnLabel_18
    303          	while (DEF_TRUE)
    304          	{
    305          		if (read == 0)
    306          		{
    307          			temp = readTemperature();
    308          
    309          			if (temp > high)
    310          			{
    311          				OSFlagPost(flagGroup, (OS_FLAGS)FLAG_TEMPER_HIGH, OS_FLAG_SET, &err);
    312          			}
    313          			else if (temp < low)
    314          			{
    315          				OSFlagPost(flagGroup, (OS_FLAGS)FLAG_TEMPER_LOW, OS_FLAG_SET, &err);
    316          			}
    317          			else
    318          			{
    319          				OSFlagPost(flagGroup, (OS_FLAGS)FLAG_TEMPER_NORMAL, OS_FLAG_SET, &err);
    320          			}
    321          
    322          			read++;
    323          		}
    324          		else if (read > 3)
   \                     ??temperTask_0: (+1)
   \        0xA   0x2804             CMP      R0,#+4
   \        0xC   0xDB49             BLT.N    ??temperTask_1
    325          		{
    326          			read = 0;
   \        0xE   0x2200             MOVS     R2,#+0
   \       0x10   0x6132             STR      R2,[R6, #+16]
   \       0x12   0xE046             B.N      ??temperTask_1
    327          		}
   \                     ??temperTask_2: (+1)
   \       0x14   0x2101             MOVS     R1,#+1
   \       0x16   0x4628             MOV      R0,R5
   \       0x18   0x....'....        BL       I2C_GenerateSTART
   \                     ??temperTask_3: (+1)
   \       0x1C   0xF44F 0x3100      MOV      R1,#+131072
   \       0x20   0x4628             MOV      R0,R5
   \       0x22   0x....'....        BL       I2C_GetFlagStatus
   \       0x26   0x2800             CMP      R0,#+0
   \       0x28   0xD1F4             BNE.N    ??temperTask_2
   \                     ??temperTask_4: (+1)
   \       0x2A   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_4: (+1)
   \       0x2E   0x2800             CMP      R0,#+0
   \       0x30   0xD0FB             BEQ.N    ??temperTask_4
   \       0x32   0x2200             MOVS     R2,#+0
   \       0x34   0x2174             MOVS     R1,#+116
   \       0x36   0x4628             MOV      R0,R5
   \       0x38   0x....'....        BL       I2C_Send7bitAddress
   \                     ??temperTask_5: (+1)
   \       0x3C   0x....             LDR.N    R1,??DataTable14_8  ;; 0x70082
   \       0x3E   0x....'....        BL       ??Subroutine3_0
   \                     ??CrossCallReturnLabel_5: (+1)
   \       0x42   0x2800             CMP      R0,#+0
   \       0x44   0xD0FA             BEQ.N    ??temperTask_5
   \       0x46   0x2107             MOVS     R1,#+7
   \       0x48   0x4628             MOV      R0,R5
   \       0x4A   0x....'....        BL       I2C_SendData
   \                     ??temperTask_6: (+1)
   \       0x4E   0x....             LDR.N    R1,??DataTable14_9  ;; 0x70084
   \       0x50   0x....'....        BL       ??Subroutine3_0
   \                     ??CrossCallReturnLabel_6: (+1)
   \       0x54   0x2800             CMP      R0,#+0
   \       0x56   0xD0FA             BEQ.N    ??temperTask_6
   \       0x58   0x2101             MOVS     R1,#+1
   \       0x5A   0x4628             MOV      R0,R5
   \       0x5C   0x....'....        BL       I2C_GenerateSTOP
   \       0x60   0x2101             MOVS     R1,#+1
   \       0x62   0x4628             MOV      R0,R5
   \       0x64   0x....'....        BL       I2C_GenerateSTART
   \                     ??temperTask_7: (+1)
   \       0x68   0x....'....        BL       ?Subroutine3
   \                     ??CrossCallReturnLabel_7: (+1)
   \       0x6C   0x2800             CMP      R0,#+0
   \       0x6E   0xD0FB             BEQ.N    ??temperTask_7
   \       0x70   0x2201             MOVS     R2,#+1
   \       0x72   0x2175             MOVS     R1,#+117
   \       0x74   0x4628             MOV      R0,R5
   \       0x76   0x....'....        BL       I2C_Send7bitAddress
   \                     ??temperTask_8: (+1)
   \       0x7A   0x....             LDR.N    R1,??DataTable14_10  ;; 0x30002
   \       0x7C   0x....'....        BL       ??Subroutine3_0
   \                     ??CrossCallReturnLabel_8: (+1)
   \       0x80   0x2800             CMP      R0,#+0
   \       0x82   0xD0FA             BEQ.N    ??temperTask_8
   \       0x84   0x4628             MOV      R0,R5
   \       0x86   0x....'....        BL       I2C_ReceiveData
   \       0x8A   0x4628             MOV      R0,R5
   \       0x8C   0x....'....        BL       I2C_GetLastEvent
   \       0x90   0x6830             LDR      R0,[R6, #+0]
   \       0x92   0x466B             MOV      R3,SP
   \       0x94   0x2201             MOVS     R2,#+1
   \       0x96   0x2110             MOVS     R1,#+16
   \       0x98   0x....'....        BL       OSFlagPost
   \       0x9C   0x6930             LDR      R0,[R6, #+16]
   \       0x9E   0x1C40             ADDS     R0,R0,#+1
   \       0xA0   0x6130             STR      R0,[R6, #+16]
    328          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
   \                     ??temperTask_1: (+1)
   \       0xA2   0x....'....        BL       ?Subroutine5
   \                     ??CrossCallReturnLabel_18: (+1)
   \       0xA6   0x6930             LDR      R0,[R6, #+16]
   \       0xA8   0x2800             CMP      R0,#+0
   \       0xAA   0xD1AE             BNE.N    ??temperTask_0
   \       0xAC   0xE7B6             B.N      ??temperTask_3
    329          	}
    330          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3: (+1)
   \        0x0   0x4621             MOV      R1,R4
   \                     ??Subroutine3_0: (+1)
   \        0x2   0x4628             MOV      R0,R5
   \        0x4   0x....'....        B.W      I2C_CheckEvent
    331          static int readTemperature()
    332          {
    333          	while (I2C_GetFlagStatus(((I2C_TypeDef *)I2C1_BASE), I2C_FLAG_BUSY))
    334          		I2C_GenerateSTART(((I2C_TypeDef *)I2C1_BASE), ENABLE);
    335          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_MODE_SELECT))
    336          		;
    337          	I2C_Send7bitAddress(((I2C_TypeDef *)I2C1_BASE), 0x74, I2C_Direction_Transmitter);
    338          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED))
    339          		;
    340          	I2C_SendData(((I2C_TypeDef *)I2C1_BASE), 0x07);
    341          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_BYTE_TRANSMITTED))
    342          		;
    343          	I2C_GenerateSTOP(((I2C_TypeDef *)I2C1_BASE), ENABLE);
    344          	I2C_GenerateSTART(((I2C_TypeDef *)I2C1_BASE), ENABLE);
    345          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_MODE_SELECT))
    346          		;
    347          	I2C_Send7bitAddress(((I2C_TypeDef *)I2C1_BASE), 0x75, I2C_Direction_Receiver);
    348          	while (!I2C_CheckEvent(((I2C_TypeDef *)I2C1_BASE), I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED))
    349          		;
    350          	int low = I2C_ReceiveData(((I2C_TypeDef *)I2C1_BASE));
    351          	if (I2C_GetLastEvent((I2C_TypeDef *)I2C1_BASE) & 0x40 != 0x40)
    352          	{
    353          		int high = I2C_ReceiveData(((I2C_TypeDef *)I2C1_BASE));
    354          		if (high & 0x80 != 0)
    355          		{
    356          			return 20; // Need Delay / return default
    357          		}
    358          		else
    359          		{
    360          			return (high << 8 + low) * 0.02 - 273.15;
    361          		}
    362          	} else {
    363                    return 20;
    364                  }
    365          
    366          	I2C_AcknowledgeConfig(((I2C_TypeDef *)I2C1_BASE), ENABLE);
    367          }
    368          
    369          /*
    370           *********************************************************************************************************
    371           *                                            passTask()
    372           *
    373           * Description : Those who are at normal body temperature are allowed to pass.
    374           *
    375           * Argument(s) : p
    376           *
    377           * Return(s)   : none.
    378           *
    379           * Caller(s)   : This is a task.
    380           *
    381           * Note(s)     : none.
    382           *********************************************************************************************************
    383           */
    384          // 정상체온인 사람은 통과를 허가하는 Task

   \                                 In section .text, align 4, keep-with-next
    385          static void passTask(void *p)
    386          {
   \                     passTask: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x....             LDR.N    R4,??DataTable14_1  ;; 0x40011000
   \        0x4   0x....             LDR.N    R5,??DataTable14_6
    387          	int err;
    388          	while (DEF_TRUE)
    389          	{
    390          		OSFlagPend(flagGroup, (OS_FLAGS)(FLAG_DETECT + FLAG_TEMPER_NORMAL), OS_FLAG_WAIT_SET_ALL + OS_FLAG_CONSUME, 100, (INT8U *)&err);
   \                     ??passTask_0: (+1)
   \        0x6   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_24: (+1)
   \        0xA   0x2105             MOVS     R1,#+5
   \        0xC   0x....'....        BL       OSFlagPend
    391          		startNotice();
   \       0x10   0xF44F 0x5180      MOV      R1,#+4096
   \       0x14   0x4620             MOV      R0,R4
   \       0x16   0x....'....        BL       GPIO_ResetBits
   \       0x1A   0xF44F 0x6100      MOV      R1,#+2048
   \       0x1E   0x4620             MOV      R0,R4
   \       0x20   0x....'....        BL       GPIO_SetBits
   \       0x24   0xF44F 0x7180      MOV      R1,#+256
   \       0x28   0x....             LDR.N    R0,??DataTable14  ;; 0x40010c00
   \       0x2A   0x....'....        BL       GPIO_ResetBits
    392          		stopAlert();
   \       0x2E   0x....'....        BL       stopAlert
    393          
    394          		OSSemPend(sem, 0, (INT8U *)&err);
   \       0x32   0x....'....        BL       ?Subroutine11
    395          		if (count == 0)
   \                     ??CrossCallReturnLabel_33: (+1)
   \       0x36   0x....'....        BL       ?Subroutine8
    396          			count = 1;
    397          		OSSemPost(sem);
    398          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
   \                     ??CrossCallReturnLabel_27: (+1)
   \       0x3A   0x....'....        BL       ?Subroutine5
    399          	}
   \                     ??CrossCallReturnLabel_17: (+1)
   \       0x3E   0xE7E2             B.N      ??passTask_0
    400          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine11: (+1)
   \        0x0   0x6868             LDR      R0,[R5, #+4]
   \        0x2   0xAA01             ADD      R2,SP,#+4
   \        0x4   0x2100             MOVS     R1,#+0
   \        0x6   0x....'....        B.W      OSSemPend

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine8: (+1)
   \        0x0   0x68A8             LDR      R0,[R5, #+8]
   \        0x2   0xB908             CBNZ.N   R0,??Subroutine8_0
   \        0x4   0x2101             MOVS     R1,#+1
   \        0x6   0x60A9             STR      R1,[R5, #+8]
   \                     ??Subroutine8_0: (+1)
   \        0x8   0x6868             LDR      R0,[R5, #+4]
   \        0xA   0x....'....        B.W      OSSemPost

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine7: (+1)
   \        0x0   0xA801             ADD      R0,SP,#+4
   \        0x2   0x9000             STR      R0,[SP, #+0]
   \        0x4   0x2364             MOVS     R3,#+100
   \        0x6   0x6828             LDR      R0,[R5, #+0]
   \        0x8   0x2282             MOVS     R2,#+130
   \        0xA   0x4770             BX       LR
    401          
    402          /*
    403           *********************************************************************************************************
    404           *                                            denyTask()
    405           *
    406           * Description : People with abnormal body temperature are not allowed to pass through.
    407           *
    408           * Argument(s) : p
    409           *
    410           * Return(s)   : none.
    411           *
    412           * Caller(s)   : This is a task.
    413           *
    414           * Note(s)     : none.
    415           *********************************************************************************************************
    416           */
    417          // 비정상체온인 사람은 통과를 불허하는 Task

   \                                 In section .text, align 4, keep-with-next
    418          static void denyTask(void *p)
    419          {
   \                     denyTask: (+1)
   \        0x0   0xB53E             PUSH     {R1-R5,LR}
   \        0x2   0x....             LDR.N    R4,??DataTable14_1  ;; 0x40011000
   \        0x4   0x....             LDR.N    R5,??DataTable14_6
    420          	int err;
    421          	while (DEF_TRUE)
    422          	{
    423          		OSFlagPend(flagGroup,
    424          				   (OS_FLAGS)(FLAG_TEMPER_HIGH + FLAG_DETECT),
    425          				   OS_FLAG_WAIT_SET_ALL + OS_FLAG_CONSUME,
    426          				   100,
    427          				   (INT8U *)&err);
   \                     ??denyTask_0: (+1)
   \        0x6   0x....'....        BL       ?Subroutine7
   \                     ??CrossCallReturnLabel_25: (+1)
   \        0xA   0x2109             MOVS     R1,#+9
   \        0xC   0x....'....        BL       OSFlagPend
    428          		startAlert();
   \       0x10   0x....'....        BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_29: (+1)
   \       0x14   0x....'....        BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_31: (+1)
   \       0x18   0xF44F 0x7180      MOV      R1,#+256
   \       0x1C   0x....             LDR.N    R0,??DataTable14  ;; 0x40010c00
   \       0x1E   0x....'....        BL       GPIO_SetBits
    429          		stopNotice();
   \       0x22   0x....'....        BL       stopNotice
    430          
    431          		OSSemPend(sem, 0, (INT8U *)&err);
   \       0x26   0x....'....        BL       ?Subroutine11
    432          		if (count == 0)
   \                     ??CrossCallReturnLabel_32: (+1)
   \       0x2A   0x....'....        BL       ?Subroutine8
    433          			count = 1;
    434          		OSSemPost(sem);
    435          
    436          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
   \                     ??CrossCallReturnLabel_26: (+1)
   \       0x2E   0x....'....        BL       ?Subroutine5
    437          	}
   \                     ??CrossCallReturnLabel_16: (+1)
   \       0x32   0xE7E8             B.N      ??denyTask_0
    438          }
    439          
    440          /*
    441           *********************************************************************************************************
    442           *                                            checkTask()
    443           *
    444           * Description : Check dot-matrix, piezo, motor.
    445           *
    446           * Argument(s) : p
    447           *
    448           * Return(s)   : none.
    449           *
    450           * Caller(s)   : This is a task.
    451           *
    452           * Note(s)     : none.
    453           *********************************************************************************************************
    454           */
    455          // 경고를 일정 시간 후 정지하도록 하는 Task

   \                                 In section .text, align 4, keep-with-next
    456          static void checkTask(void *p)
    457          {
   \                     checkTask: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    458          	CPU_INT08U err;
    459          	stopAlert();
   \        0x2   0x....'....        BL       stopAlert
    460          	stopNotice();
   \        0x6   0x....'....        BL       stopNotice
   \        0xA   0x....             LDR.N    R4,??DataTable14_6
    461          	while (DEF_TRUE)
    462          	{
    463          
    464          		if (count != 0)
   \                     ??checkTask_0: (+1)
   \        0xC   0x68A0             LDR      R0,[R4, #+8]
   \        0xE   0xB1A0             CBZ.N    R0,??checkTask_1
    465          		{
    466          			check++;
   \       0x10   0x68E0             LDR      R0,[R4, #+12]
   \       0x12   0x1C40             ADDS     R0,R0,#+1
    467          			if (check > 3)
   \       0x14   0x2804             CMP      R0,#+4
   \       0x16   0xDB0F             BLT.N    ??checkTask_2
    468          			{
    469          				stopAlert();
   \       0x18   0x60E0             STR      R0,[R4, #+12]
   \       0x1A   0x....'....        BL       stopAlert
    470          				stopNotice();
   \       0x1E   0x....'....        BL       stopNotice
    471          
    472          				OSSemPend(sem, 0, &err);
   \       0x22   0x6860             LDR      R0,[R4, #+4]
   \       0x24   0x466A             MOV      R2,SP
   \       0x26   0x2100             MOVS     R1,#+0
   \       0x28   0x....'....        BL       OSSemPend
    473          				count = 0;
   \       0x2C   0x2000             MOVS     R0,#+0
   \       0x2E   0x60A0             STR      R0,[R4, #+8]
    474          				OSSemPost(sem);
   \       0x30   0x6860             LDR      R0,[R4, #+4]
   \       0x32   0x....'....        BL       OSSemPost
    475          				check = 0;
   \       0x36   0x2000             MOVS     R0,#+0
   \                     ??checkTask_2: (+1)
   \       0x38   0x60E0             STR      R0,[R4, #+12]
    476          			}
    477          		}
    478          
    479          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
   \                     ??checkTask_1: (+1)
   \       0x3A   0x....'....        BL       ?Subroutine5
    480          	}
   \                     ??CrossCallReturnLabel_15: (+1)
   \       0x3E   0xE7E5             B.N      ??checkTask_0
    481          }
    482          

   \                                 In section .text, align 2, keep-with-next
    483          static void stopAlert()
    484          {
   \                     stopAlert: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    485          	// RED LED
    486          	GPIO_SetBits(GPIOC, GPIO_Pin_12);
   \        0x2   0x....             B.N      ?Subroutine0
    487          	// GREEN LED
    488          	GPIO_ResetBits(GPIOC, GPIO_Pin_11);
    489          	// BUZZER
    490          	GPIO_ResetBits(GPIOB, GPIO_Pin_8);
    491          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \        0x0   0x....             LDR.N    R4,??DataTable14_1  ;; 0x40011000
   \        0x2   0x....'....        BL       ?Subroutine9
   \                     ??CrossCallReturnLabel_28: (+1)
   \        0x6   0x....'....        BL       ?Subroutine10
   \                     ??CrossCallReturnLabel_30: (+1)
   \        0xA   0xE8BD 0x4010      POP      {R4,LR}
   \        0xE   0xF44F 0x7180      MOV      R1,#+256
   \       0x12   0x....             LDR.N    R0,??DataTable14  ;; 0x40010c00
   \       0x14   0x....'....        B.W      GPIO_ResetBits

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine10: (+1)
   \        0x0   0xF44F 0x6100      MOV      R1,#+2048
   \        0x4   0x4620             MOV      R0,R4
   \        0x6   0x....'....        B.W      GPIO_ResetBits

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine9: (+1)
   \        0x0   0xF44F 0x5180      MOV      R1,#+4096
   \        0x4   0x4620             MOV      R0,R4
   \        0x6   0x....'....        B.W      GPIO_SetBits
    492          // 통과 거부
    493          static void startAlert()
    494          {
    495          	// RED LED
    496          	GPIO_SetBits(GPIOC, GPIO_Pin_12);
    497          	// GREEN LED
    498          	GPIO_ResetBits(GPIOC, GPIO_Pin_11);
    499          	// BUZZER
    500          	GPIO_SetBits(GPIOB, GPIO_Pin_8);
    501          }
    502          

   \                                 In section .text, align 2, keep-with-next
    503          static void stopNotice()
    504          {
   \                     stopNotice: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    505          	// RED LED
    506          	GPIO_SetBits(GPIOC, GPIO_Pin_12);
   \        0x2                      REQUIRE ?Subroutine0
   \        0x2                      ;; // Fall through to label ?Subroutine0
    507          	// GREEN LED
    508          	GPIO_ResetBits(GPIOC, GPIO_Pin_11);
    509          	// BUZZER
    510          	GPIO_ResetBits(GPIOB, GPIO_Pin_8);
    511          }
    512          // 통과 허용
    513          static void startNotice()
    514          {
    515          	// RED LED
    516          	GPIO_ResetBits(GPIOC, GPIO_Pin_12);
    517          	// GREEN LED
    518          	GPIO_SetBits(GPIOC, GPIO_Pin_11);
    519          	// BUZZER
    520          	GPIO_ResetBits(GPIOB, GPIO_Pin_8);
    521          }
    522          
    523          /*
    524            *********************************************************************************************************
    525            *                                            startTask()
    526            *
    527            * Description : Init task.
    528            *
    529            * Argument(s) : p
    530            *
    531            * Return(s)   : none.
    532            *
    533            * Caller(s)   : This is a task.
    534            *
    535            * Note(s)     : none.
    536            *********************************************************************************************************
    537            */
    538          // 경고를 일정 시간 후 정지하도록 하는 Task

   \                                 In section .text, align 4, keep-with-next
    539          static void startTask(void *p)
    540          {
   \                     startTask: (+1)
   \        0x0   0xB51C             PUSH     {R2-R4,LR}
    541          	CPU_INT08U err;
    542          
    543          	OS_CPU_SysTickInit();
   \        0x2   0x....'....        BL       OS_CPU_SysTickInit
    544          
    545          	// Create Event Flag
    546          	flagGroup = OSFlagCreate(0, &err);
   \        0x6   0x4669             MOV      R1,SP
   \        0x8   0x2000             MOVS     R0,#+0
   \        0xA   0x....             LDR.N    R4,??DataTable14_6
   \        0xC   0x....'....        BL       OSFlagCreate
   \       0x10   0x6020             STR      R0,[R4, #+0]
    547          
    548          	// Create semaphore
    549          	sem = OSSemCreate(0);
   \       0x12   0x2000             MOVS     R0,#+0
   \       0x14   0x....'....        BL       OSSemCreate
   \       0x18   0x6060             STR      R0,[R4, #+4]
    550          
    551          	stopAlert();
   \       0x1A   0x....'....        BL       stopAlert
    552          	stopNotice();
   \       0x1E   0x....'....        BL       stopNotice
    553          #if (OS_TASK_STAT_EN > 0)
    554          	OSStatInit(); /* Determine CPU capacity.                              */
   \       0x22   0x....'....        BL       OSStatInit
    555          #endif
    556          
    557          #if ((APP_PROBE_COM_EN == DEF_ENABLED) || \
    558          	 (APP_OS_PROBE_EN == DEF_ENABLED))
    559          	App_InitProbe();
   \       0x26   0x....'....        BL       OSProbe_Init
   \       0x2A   0x....'....        ADR.W    R0,App_ProbeCallback
   \       0x2E   0x....'....        BL       OSProbe_SetCallback
   \       0x32   0x20FA             MOVS     R0,#+250
   \       0x34   0x....'....        BL       OSProbe_SetDelay
   \       0x38   0x....'....        BL       ProbeCom_Init
    560          #endif
    561          
    562          	while (DEF_TRUE)
    563          	{
    564          		OSTimeDlyHMSM(0, 0, 0, DELAY_TIME); // To run other tasks
   \                     ??startTask_0: (+1)
   \       0x3C   0x....'....        BL       ?Subroutine5
    565          	}
   \                     ??CrossCallReturnLabel_14: (+1)
   \       0x40   0xE7FC             B.N      ??startTask_0
    566          }
    567          
    568          /*
    569           *********************************************************************************************************
    570           *                                          App_DispScr_SignOn()
    571           *
    572           * Description : Display uC/OS-II system information on the LCD.
    573           *
    574           * Argument(s) : none.
    575           *
    576           * Return(s)   : none.
    577           *
    578           * Caller(s)   : TaskUserIF().
    579           *
    580           * Note(s)     : none.
    581           *********************************************************************************************************
    582           */
    583          
    584          static void App_DispScr_SignOn(void)
    585          {
    586          }
    587          
    588          /*
    589           *********************************************************************************************************
    590           *                                          App_DispScr_SignOn()
    591           *
    592           * Description : Display uC/OS-II system information on the LCD.
    593           *
    594           * Argument(s) : none.
    595           *
    596           * Return(s)   : none.
    597           *
    598           * Caller(s)   : TaskUserIF().
    599           *
    600           * Note(s)     : none.
    601           *********************************************************************************************************
    602           */
    603          
    604          static void App_DispScr_TaskNames(void)
    605          {
    606          }
    607          
    608          /*
    609           *********************************************************************************************************
    610           *                                             App_InitProbe()
    611           *
    612           * Description : Initialize uC/Probe target code.
    613           *
    614           * Argument(s) : none.
    615           *
    616           * Return(s)   : none.
    617           *
    618           * Caller(s)   : App_TaskStart().
    619           *
    620           * Note(s)     : none.
    621           *********************************************************************************************************
    622           */
    623          
    624          #if ((APP_PROBE_COM_EN == DEF_ENABLED) || \
    625          	 (APP_OS_PROBE_EN == DEF_ENABLED))
    626          static void App_InitProbe(void)
    627          {
    628          #if (APP_OS_PROBE_EN == DEF_ENABLED)
    629          	(void)App_ProbeCounts;
    630          	(void)App_ProbeB1;
    631          
    632          #if ((APP_PROBE_COM_EN == DEF_ENABLED) && \
    633          	 (PROBE_COM_STAT_EN == DEF_ENABLED))
    634          	(void)App_ProbeComRxPktSpd;
    635          	(void)App_ProbeComTxPktSpd;
    636          	(void)App_ProbeComTxSymSpd;
    637          	(void)App_ProbeComTxSymByteSpd;
    638          #endif
    639          
    640          	OSProbe_Init();
    641          	OSProbe_SetCallback(App_ProbeCallback);
    642          	OSProbe_SetDelay(250);
    643          #endif
    644          
    645          #if (APP_PROBE_COM_EN == DEF_ENABLED)
    646          	ProbeCom_Init(); /* Initialize the uC/Probe communications module.       */
    647          #endif
    648          }
    649          #endif
    650          
    651          /*
    652           *********************************************************************************************************
    653           *                                         AppProbeCallback()
    654           *
    655           * Description : uC/Probe OS plugin callback.
    656           *
    657           * Argument(s) : none.
    658           *
    659           * Return(s)   : none.
    660           *
    661           * Caller(s)   : uC/Probe OS plugin task.
    662           *
    663           * Note(s)     : none.
    664           *********************************************************************************************************
    665           */
    666          
    667          #if (APP_OS_PROBE_EN == DEF_ENABLED)

   \                                 In section .text, align 4, keep-with-next
    668          static void App_ProbeCallback(void)
    669          {
   \                     App_ProbeCallback: (+1)
   \        0x0   0xB510             PUSH     {R4,LR}
    670          #if ((APP_PROBE_COM_EN == DEF_ENABLED) && \
    671          	 (PROBE_COM_STAT_EN == DEF_ENABLED))
    672          	CPU_INT32U ctr_curr;
    673          	CPU_INT32U rxpkt_curr;
    674          	CPU_INT32U txpkt_curr;
    675          	CPU_INT32U sym_curr;
    676          	CPU_INT32U symbyte_curr;
    677          #endif
    678          
    679          	App_ProbeCounts++;
   \        0x2   0x....             LDR.N    R4,??DataTable14_11
   \        0x4   0x6961             LDR      R1,[R4, #+20]
   \        0x6   0x1C49             ADDS     R1,R1,#+1
   \        0x8   0x6161             STR      R1,[R4, #+20]
    680          
    681          	App_ProbeB1 = BSP_PB_GetStatus(1);
   \        0xA   0x2001             MOVS     R0,#+1
   \        0xC   0x....'....        BL       BSP_PB_GetStatus
    682          
    683          #if ((APP_PROBE_COM_EN == DEF_ENABLED) && \
    684          	 (PROBE_COM_STAT_EN == DEF_ENABLED))
    685          	ctr_curr = OSTime;
   \       0x10   0x....             LDR.N    R1,??DataTable14_12
   \       0x12   0x6808             LDR      R0,[R1, #+0]
    686          	rxpkt_curr = ProbeCom_RxPktCtr;
    687          	txpkt_curr = ProbeCom_TxPktCtr;
    688          	sym_curr = ProbeCom_TxSymCtr;
    689          	symbyte_curr = ProbeCom_TxSymByteCtr;
    690          
    691          	if ((ctr_curr - App_ProbeComCtrLast) >= OS_TICKS_PER_SEC)
   \       0x14   0x6922             LDR      R2,[R4, #+16]
   \       0x16   0x1A82             SUBS     R2,R0,R2
   \       0x18   0xF5B2 0x7F7A      CMP      R2,#+1000
   \       0x1C   0xD30C             BCC.N    ??App_ProbeCallback_0
    692          	{
    693          		App_ProbeComRxPktSpd = ((CPU_FP32)(rxpkt_curr - App_ProbeComRxPktLast) / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    694          		App_ProbeComTxPktSpd = ((CPU_FP32)(txpkt_curr - App_ProbeComTxPktLast) / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    695          		App_ProbeComTxSymSpd = ((CPU_FP32)(sym_curr - App_ProbeComTxSymLast) / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    696          		App_ProbeComTxSymByteSpd = ((CPU_FP32)(symbyte_curr - App_ProbeComTxSymByteLast) / (ctr_curr - App_ProbeComCtrLast)) * OS_TICKS_PER_SEC;
    697          
    698          		App_ProbeComCtrLast = ctr_curr;
   \       0x1E   0x6120             STR      R0,[R4, #+16]
    699          		App_ProbeComRxPktLast = rxpkt_curr;
    700          		App_ProbeComTxPktLast = txpkt_curr;
   \       0x20   0x....             LDR.N    R2,??DataTable14_13
   \       0x22   0x....             LDR.N    R0,??DataTable14_14
   \       0x24   0x6801             LDR      R1,[R0, #+0]
    701          		App_ProbeComTxSymLast = sym_curr;
   \       0x26   0x....             LDR.N    R0,??DataTable14_15
   \       0x28   0x6021             STR      R1,[R4, #+0]
   \       0x2A   0x6813             LDR      R3,[R2, #+0]
    702          		App_ProbeComTxSymByteLast = symbyte_curr;
   \       0x2C   0x....             LDR.N    R2,??DataTable14_16
   \       0x2E   0x6063             STR      R3,[R4, #+4]
   \       0x30   0x6801             LDR      R1,[R0, #+0]
   \       0x32   0x60A1             STR      R1,[R4, #+8]
   \       0x34   0x6810             LDR      R0,[R2, #+0]
   \       0x36   0x60E0             STR      R0,[R4, #+12]
    703          	}
    704          #endif
    705          }
   \                     ??App_ProbeCallback_0: (+1)
   \       0x38   0xBD10             POP      {R4,PC}          ;; return
    706          #endif
    707          
    708          /*
    709           *********************************************************************************************************
    710           *                                      App_FormatDec()
    711           *
    712           * Description : Convert a decimal value to ASCII (without leading zeros).
    713           *
    714           * Argument(s) : pstr            Pointer to the destination ASCII string.
    715           *
    716           *               value           Value to convert (assumes an unsigned value).
    717           *
    718           *               digits          The desired number of digits.
    719           *
    720           * Return(s)   : none.
    721           *
    722           * Caller(s)   : various.
    723           *
    724           * Note(s)     : none.
    725           *********************************************************************************************************
    726           */
    727          
    728          /*
    729            *********************************************************************************************************
    730            *********************************************************************************************************
    731            *                                          uC/OS-II APP HOOKS
    732            *********************************************************************************************************
    733            *********************************************************************************************************
    734            */
    735          
    736          #if (OS_APP_HOOKS_EN > 0)
    737          /*
    738             *********************************************************************************************************
    739             *                                      TASK CREATION HOOK (APPLICATION)
    740             *
    741             * Description : This function is cal when a task is created.
    742             *
    743             * Argument(s) : ptcb   is a pointer to the task control block of the task being created.
    744             *
    745             * Note(s)     : (1) Interrupts are disabled during this call.
    746             *********************************************************************************************************
    747             */
    748          

   \                                 In section .text, align 2, keep-with-next
    749          void App_TaskCreateHook(OS_TCB *ptcb)
    750          {
    751          #if ((APP_OS_PROBE_EN == DEF_ENABLED) && \
    752          	 (OS_PROBE_HOOKS_EN == DEF_ENABLED))
    753          	OSProbe_TaskCreateHook(ptcb);
   \                     App_TaskCreateHook: (+1)
   \        0x0   0x....'....        B.W      OSProbe_TaskCreateHook
    754          #endif
    755          }
    756          
    757          /*
    758           *********************************************************************************************************
    759           *                                    TASK DELETION HOOK (APPLICATION)
    760           *
    761           * Description : This function is called when a task is deleted.
    762           *
    763           * Argument(s) : ptcb   is a pointer to the task control block of the task being deleted.
    764           *
    765           * Note(s)     : (1) Interrupts are disabled during this call.
    766           *********************************************************************************************************
    767           */
    768          

   \                                 In section .text, align 2, keep-with-next
    769          void App_TaskDelHook(OS_TCB *ptcb)
    770          {
    771          	(void)ptcb;
    772          }
   \                     App_TaskDelHook: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    773          
    774          /*
    775           *********************************************************************************************************
    776           *                                      IDLE TASK HOOK (APPLICATION)
    777           *
    778           * Description : This function is called by OSTaskIdleHook(), which is called by the idle task.  This hook
    779           *               has been added to allow you to do such things as STOP the CPU to conserve power.
    780           *
    781           * Argument(s) : none.
    782           *
    783           * Note(s)     : (1) Interrupts are enabled during this call.
    784           *********************************************************************************************************
    785           */
    786          
    787          #if OS_VERSION >= 251

   \                                 In section .text, align 2, keep-with-next
    788          void App_TaskIdleHook(void)
    789          {
    790          }
   \                     App_TaskIdleHook: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    791          #endif
    792          
    793          /*
    794           *********************************************************************************************************
    795           *                                        STATISTIC TASK HOOK (APPLICATION)
    796           *
    797           * Description : This function is called by OSTaskStatHook(), which is called every second by uC/OS-II's
    798           *               statistics task.  This allows your application to add functionality to the statistics task.
    799           *
    800           * Argument(s) : none.
    801           *********************************************************************************************************
    802           */
    803          

   \                                 In section .text, align 2, keep-with-next
    804          void App_TaskStatHook(void)
    805          {
    806          }
   \                     App_TaskStatHook: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    807          
    808          /*
    809           *********************************************************************************************************
    810           *                                        TASK SWITCH HOOK (APPLICATION)
    811           *
    812           * Description : This function is called when a task switch is performed.  This allows you to perform other
    813           *               operations during a context switch.
    814           *
    815           * Argument(s) : none.
    816           *
    817           * Note(s)     : (1) Interrupts are disabled during this call.
    818           *
    819           *               (2) It is assumed that the global pointer 'OSTCBHighRdy' points to the TCB of the task that
    820           *                   will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
    821           *                  task being switched out (i.e. the preempted task).
    822           *********************************************************************************************************
    823           */
    824          
    825          #if OS_TASK_SW_HOOK_EN > 0

   \                                 In section .text, align 2, keep-with-next
    826          void App_TaskSwHook(void)
    827          {
    828          #if ((APP_OS_PROBE_EN == DEF_ENABLED) && \
    829          	 (OS_PROBE_HOOKS_EN == DEF_ENABLED))
    830          	OSProbe_TaskSwHook();
   \                     App_TaskSwHook: (+1)
   \        0x0   0x....'....        B.W      OSProbe_TaskSwHook
    831          #endif
    832          }
    833          #endif
    834          
    835          /*
    836           *********************************************************************************************************
    837           *                                     OS_TCBInit() HOOK (APPLICATION)
    838           *
    839           * Description : This function is called by OSTCBInitHook(), which is called by OS_TCBInit() after setting
    840           *               up most of the TCB.
    841           *
    842           * Argument(s) : ptcb    is a pointer to the TCB of the task being created.
    843           *
    844           * Note(s)     : (1) Interrupts may or may not be ENABLED during this call.
    845           *********************************************************************************************************
    846           */
    847          
    848          #if OS_VERSION >= 204

   \                                 In section .text, align 2, keep-with-next
    849          void App_TCBInitHook(OS_TCB *ptcb)
    850          {
    851          	(void)ptcb;
    852          }
   \                     App_TCBInitHook: (+1)
   \        0x0   0x4770             BX       LR               ;; return
    853          #endif
    854          
    855          /*
    856           *********************************************************************************************************
    857           *                                        TICK HOOK (APPLICATION)
    858           *
    859           * Description : This function is called every tick.
    860           *
    861           * Argument(s) : none.
    862           *
    863           * Note(s)     : (1) Interrupts may or may not be ENABLED during this call.
    864           *********************************************************************************************************
    865           */
    866          
    867          #if OS_TIME_TICK_HOOK_EN > 0

   \                                 In section .text, align 2, keep-with-next
    868          void App_TimeTickHook(void)
    869          {
    870          #if ((APP_OS_PROBE_EN == DEF_ENABLED) && \
    871          	 (OS_PROBE_HOOKS_EN == DEF_ENABLED))
    872          	OSProbe_TickHook();
   \                     App_TimeTickHook: (+1)
   \        0x0   0x....'....        B.W      OSProbe_TickHook
    873          #endif
    874          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2: (+1)
   \        0x0   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \        0x4   0xF88D 0x1003      STRB     R1,[SP, #+3]
   \        0x8   0x2203             MOVS     R2,#+3
   \        0xA   0xF88D 0x2002      STRB     R2,[SP, #+2]
   \        0xE   0x4669             MOV      R1,SP
   \       0x10   0x4770             BX       LR

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \        0x0   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \        0x4   0xF88D 0x1003      STRB     R1,[SP, #+3]
   \        0x8   0x2203             MOVS     R2,#+3
   \        0xA   0xF88D 0x2002      STRB     R2,[SP, #+2]
   \        0xE   0x4669             MOV      R1,SP
   \       0x10   0x4628             MOV      R0,R5
   \       0x12   0x....'....        B.W      GPIO_Init

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \        0x0   0x4001'0C00        DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \        0x0   0x4001'1000        DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \        0x0   0x4001'2400        DC32     0x40012400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_3:
   \        0x0   0x0001'86A0        DC32     0x186a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_4:
   \        0x0   0x4000'5400        DC32     0x40005400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_5:
   \        0x0   0x....'....        DC32     detectTaskStack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_6:
   \        0x0   0x....'....        DC32     flagGroup

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_7:
   \        0x0   0x0003'0001        DC32     0x30001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_8:
   \        0x0   0x0007'0082        DC32     0x70082

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_9:
   \        0x0   0x0007'0084        DC32     0x70084

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_10:
   \        0x0   0x0003'0002        DC32     0x30002

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_11:
   \        0x0   0x....'....        DC32     App_ProbeComRxPktLast

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_12:
   \        0x0   0x....'....        DC32     OSTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_13:
   \        0x0   0x....'....        DC32     ProbeCom_TxPktCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_14:
   \        0x0   0x....'....        DC32     ProbeCom_RxPktCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_15:
   \        0x0   0x....'....        DC32     ProbeCom_TxSymCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_16:
   \        0x0   0x....'....        DC32     ProbeCom_TxSymByteCtr

   \                                 In section .text, align 4, keep-with-next
   \                     ?_0:
   \        0x0   0x44 0x65          DC8 "Detect Task"

   \              0x74 0x65    

   \              0x63 0x74    

   \              0x20 0x54    

   \              0x61 0x73    

   \              0x6B 0x00

   \                                 In section .text, align 4, keep-with-next
   \                     ?_1:
   \        0x0   0x54 0x65          DC8 "Temperature Task"

   \              0x6D 0x70    

   \              0x65 0x72    

   \              0x61 0x74    

   \              0x75 0x72    

   \              0x65 0x20    

   \              0x54 0x61    

   \              0x73 0x6B    

   \              0x00
   \       0x11                      DS8 3

   \                                 In section .text, align 4, keep-with-next
   \                     ?_2:
   \        0x0   0x50 0x61          DC8 "Pass Task"

   \              0x73 0x73    

   \              0x20 0x54    

   \              0x61 0x73    

   \              0x6B 0x00
   \        0xA                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ?_3:
   \        0x0   0x44 0x65          DC8 "Deny Task"

   \              0x6E 0x79    

   \              0x20 0x54    

   \              0x61 0x73    

   \              0x6B 0x00
   \        0xA                      DS8 2

   \                                 In section .text, align 4, keep-with-next
   \                     ?_4:
   \        0x0   0x43 0x68          DC8 "Check Task"

   \              0x65 0x63    

   \              0x6B 0x20    

   \              0x54 0x61    

   \              0x73 0x6B    

   \              0x00
   \        0xB                      DS8 1

   \                                 In section .text, align 4, keep-with-next
   \                     ?_5:
   \        0x0   0x53 0x74          DC8 "Start Task"

   \              0x61 0x72    

   \              0x74 0x20    

   \              0x54 0x61    

   \              0x73 0x6B    

   \              0x00
   \        0xB                      DS8 1
    875          #endif
    876          #endif
    877          
    878          static void initAll()
    879          {
    880          	ADC_InitTypeDef adc_init;
    881          	GPIO_InitTypeDef gpio_init;
    882          	I2C_InitTypeDef i2c_init;
    883          
    884          	// CLOCK
    885          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
    886          	//RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
    887          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE);
    888          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    889          	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
    890          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    891          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
    892          
    893          // PIN
    894          // ADC - 인체 감지
    895          #ifdef AUTO
    896          	gpio_init.GPIO_Pin = GPIO_Pin_1;
    897          	gpio_init.GPIO_Mode = GPIO_Mode_AIN;
    898          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    899          	GPIO_Init(GPIOB, &gpio_init);
    900          #endif
    901          
    902          	// I2C - 온도 센서
    903          	gpio_init.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
    904          	gpio_init.GPIO_Mode = GPIO_Mode_AF_OD;
    905          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    906          	GPIO_Init(GPIOB, &gpio_init);
    907          
    908          #ifdef MANUAL
    909          	// touch
    910          	gpio_init.GPIO_Pin = GPIO_Pin_9;
    911          	gpio_init.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    912          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    913          	GPIO_Init(GPIOC, &gpio_init);
    914          #endif
    915          
    916          	// 부저
    917          	gpio_init.GPIO_Pin = GPIO_Pin_8;
    918          	gpio_init.GPIO_Mode = GPIO_Mode_Out_PP;
    919          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    920          	GPIO_Init(GPIOB, &gpio_init);
    921          
    922          	// LED
    923          	gpio_init.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12;
    924          	gpio_init.GPIO_Mode = GPIO_Mode_Out_PP;
    925          	gpio_init.GPIO_Speed = GPIO_Speed_50MHz;
    926          	GPIO_Init(GPIOC, &gpio_init);
    927          
    928          	// CONFIG
    929          	// ADC
    930          	adc_init.ADC_Mode = ADC_Mode_Independent;
    931          	adc_init.ADC_ScanConvMode = ENABLE;
    932          	adc_init.ADC_ContinuousConvMode = ENABLE;
    933          	adc_init.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
    934          	adc_init.ADC_DataAlign = ADC_DataAlign_Right;
    935          	adc_init.ADC_NbrOfChannel = 1;
    936          	ADC_Init(ADC1, &adc_init);
    937          	ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 1, ADC_SampleTime_41Cycles5);
    938          	ADC_ITConfig(ADC1, ADC_IT_EOC, ENABLE);
    939          	ADC_Cmd(ADC1, ENABLE);
    940          
    941          	ADC_ResetCalibration(ADC1);
    942          	while (ADC_GetResetCalibrationStatus(ADC1) != RESET)
    943          		;
    944          	ADC_StartCalibration(ADC1);
    945          	while (ADC_GetCalibrationStatus(ADC1) != RESET)
    946          		;
    947          	ADC_SoftwareStartConvCmd(ADC1, ENABLE);
    948          
    949          	// I2C
    950          	i2c_init.I2C_Mode = I2C_Mode_I2C;
    951          	i2c_init.I2C_DutyCycle = I2C_DutyCycle_2;
    952          	i2c_init.I2C_OwnAddress1 = 0;
    953          	i2c_init.I2C_Ack = I2C_Ack_Enable;
    954          	i2c_init.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    955          	i2c_init.I2C_ClockSpeed = 100000;
    956          	I2C_Init(((I2C_TypeDef *)I2C1_BASE), &i2c_init);
    957          	I2C_Cmd(((I2C_TypeDef *)I2C1_BASE), ENABLE);
    958          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   App_ProbeCallback
         8   -> BSP_PB_GetStatus
       0   App_TCBInitHook
       0   App_TaskCreateHook
         0   -> OSProbe_TaskCreateHook
       0   App_TaskDelHook
       0   App_TaskIdleHook
       0   App_TaskStatHook
       0   App_TaskSwHook
         0   -> OSProbe_TaskSwHook
       0   App_TimeTickHook
         0   -> OSProbe_TickHook
      16   checkTask
        16   -> OSSemPend
        16   -> OSSemPost
        16   -> OSTimeDlyHMSM
        16   -> stopAlert
        16   -> stopNotice
      24   denyTask
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> OSFlagPend
        24   -> OSSemPend
        24   -> OSSemPost
        24   -> OSTimeDlyHMSM
        24   -> stopNotice
       8   detectTask
         8   -> GPIO_ReadInputDataBit
         8   -> OSFlagPost
         8   -> OSTimeDlyHMSM
      56   main
        56   -> ADC_Cmd
        56   -> ADC_GetCalibrationStatus
        56   -> ADC_GetResetCalibrationStatus
        56   -> ADC_ITConfig
        56   -> ADC_Init
        56   -> ADC_RegularChannelConfig
        56   -> ADC_ResetCalibration
        56   -> ADC_SoftwareStartConvCmd
        56   -> ADC_StartCalibration
        56   -> BSP_IntDisAll
        56   -> GPIO_Init
        56   -> I2C_Cmd
        56   -> I2C_Init
        56   -> OSInit
        56   -> OSStart
        56   -> OSTaskCreateExt
        56   -> OSTaskNameSet
        56   -> RCC_APB1PeriphClockCmd
        56   -> RCC_APB2PeriphClockCmd
      24   passTask
        24   -> GPIO_ResetBits
        24   -> GPIO_SetBits
        24   -> OSFlagPend
        24   -> OSSemPend
        24   -> OSSemPost
        24   -> OSTimeDlyHMSM
        24   -> stopAlert
      16   startTask
        16   -> OSFlagCreate
        16   -> OSProbe_Init
        16   -> OSProbe_SetCallback
        16   -> OSProbe_SetDelay
        16   -> OSSemCreate
        16   -> OSStatInit
        16   -> OSTimeDlyHMSM
        16   -> OS_CPU_SysTickInit
        16   -> ProbeCom_Init
        16   -> stopAlert
        16   -> stopNotice
       8   stopAlert
         0   -> GPIO_ResetBits
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       0   stopNotice
         0   -> GPIO_ResetBits
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
      24   temperTask
        24   -> I2C_CheckEvent
        24   -> I2C_GenerateSTART
        24   -> I2C_GenerateSTOP
        24   -> I2C_GetFlagStatus
        24   -> I2C_GetLastEvent
        24   -> I2C_ReceiveData
        24   -> I2C_Send7bitAddress
        24   -> I2C_SendData
        24   -> OSFlagPost
        24   -> OSTimeDlyHMSM


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_15
       4  ??DataTable14_16
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      24  ?Subroutine0
      22  ?Subroutine1
      10  ?Subroutine10
      10  ?Subroutine11
      18  ?Subroutine2
       8  ?Subroutine3
      12  ?Subroutine4
      14  ?Subroutine5
      12  ?Subroutine6
      12  ?Subroutine7
      14  ?Subroutine8
      10  ?Subroutine9
      12  ?_0
      20  ?_1
      12  ?_2
      12  ?_3
      12  ?_4
      12  ?_5
       1  App_ProbeB1
      58  App_ProbeCallback
      24  App_ProbeComRxPktLast
          App_ProbeComTxPktLast
          App_ProbeComTxSymLast
          App_ProbeComTxSymByteLast
          App_ProbeComCtrLast
          App_ProbeCounts
       4  App_ProbeComRxPktSpd
       4  App_ProbeComTxPktSpd
       4  App_ProbeComTxSymByteSpd
       4  App_ProbeComTxSymSpd
       2  App_TCBInitHook
       4  App_TaskCreateHook
       2  App_TaskDelHook
       2  App_TaskIdleHook
       2  App_TaskStatHook
       4  App_TaskSwHook
       4  App_TimeTickHook
      64  checkTask
      52  denyTask
      40  detectTask
   3'072  detectTaskStack
          temperatureTaskStack
          passTaskStack
          denyTaskStack
          checkTaskStack
          startTaskStack
      20  flagGroup
          sem
          count
          check
          read
     550  main
      64  passTask
      66  startTask
       4  stopAlert
       2  stopNotice
     174  temperTask

 
 3'133 bytes in section .bss
 1'408 bytes in section .text
 
 1'408 bytes of CODE memory
 3'133 bytes of DATA memory

Errors: none
Warnings: 6
